{"version":3,"sources":["class/Metadata.ts"],"names":[],"mappings":"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","file":"Metadata.js","sourcesContent":["import \"reflect-metadata\";\nimport {getClass} from \"../utils\";\n\n/**\n * @stable\n */\nexport class Metadata {\n  /**\n   * Gets the metadata value for the provided metadata key on the target object or its prototype chain.\n   * @param key A key used to store and retrieve metadata.\n   * @param target The target object on which the metadata is defined.\n   * @param propertyKey The property key for the target.\n   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n   * @example\n   *\n   * ```typescript\n   * class Example {\n   *     // property declarations are not part of ES6, though they are valid in TypeScript:\n   *     // static staticProperty;\n   *     // property;\n   *\n   *     static staticMethod(p) { }\n   *     method(p) { }\n   * }\n   *\n   * // constructor\n   * result = Metadata.get(\"custom:annotation\", Example);\n   *\n   * // property (on constructor)\n   * result = Metadata.get(\"custom:annotation\", Example, \"staticProperty\");\n   *\n   * // property (on prototype)\n   * result = Metadata.get(\"custom:annotation\", Example.prototype, \"property\");\n   *\n   * // method (on constructor)\n   * result = Metadata.get(\"custom:annotation\", Example, \"staticMethod\");\n   *\n   * // method (on prototype)\n   * result = Metadata.get(\"custom:annotation\", Example.prototype, \"method\");\n   * ```\n   *\n   */\n  static get(key: string, target: any, propertyKey?: string | symbol): any {\n    return Reflect.getMetadata(key, getClass(target), propertyKey!);\n  }\n\n  /**\n   * Gets the metadata value for the provided metadata key on the target object or its prototype chain.\n   * @param key A key used to store and retrieve metadata.\n   * @param target The target object on which the metadata is defined.\n   * @param propertyKey The property key for the target.\n   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n   * @example\n   *\n   * ```typescript\n   * class Example {\n   *     // property declarations are not part of ES6, though they are valid in TypeScript:\n   *     // static staticProperty;\n   *     // property;\n   *\n   *     static staticMethod(p) { }\n   *     method(p) { }\n   * }\n   *\n   * // constructor\n   * result = Metadata.getOwn(\"custom:annotation\", Example);\n   *\n   * // property (on constructor)\n   * result = Metadata.getOwn(\"custom:annotation\", Example, \"staticProperty\");\n   *\n   * // property (on prototype)\n   * result = Metadata.getOwn(\"custom:annotation\", Example.prototype, \"property\");\n   *\n   * // method (on constructor)\n   * result = Metadata.getOwn(\"custom:annotation\", Example, \"staticMethod\");\n   *\n   * // method (on prototype)\n   * result = Metadata.getOwn(\"custom:annotation\", Example.prototype, \"method\");\n   * ```\n   *\n   */\n  static getOwn(key: string, target: any, propertyKey?: string | symbol): any {\n    return Reflect.getOwnMetadata(key, getClass(target), propertyKey!);\n  }\n\n  /**\n   * Gets the metadata value for the provided metadata DESIGN_TYPE on the target object or its prototype chain.\n   * @param target The target object on which the metadata is defined.\n   * @param propertyKey The property key for the target.\n   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n   * @example\n   *\n   * ```typescript\n   * class Example {\n   *     // property declarations are not part of ES6, though they are valid in TypeScript:\n   *     // static staticProperty;\n   *     // property;\n   *\n   *     static staticMethod(p) { }\n   *     method(p) { }\n   * }\n   *\n   * // on contructor\n   * result = Metadata.getType(Example);\n   *\n   * // property (on constructor)\n   * result = Metadata.getType(Example, \"staticProperty\");\n   *\n   * // method (on constructor)\n   * result = Metadata.getType(Example, \"staticMethod\");\n   * ```\n   *\n   */\n  static getType(target: any, propertyKey?: string | symbol): any {\n    return Reflect.getMetadata(DESIGN_TYPE, target, propertyKey!);\n  }\n\n  /**\n   * Gets the metadata value for the provided metadata DESIGN_TYPE on the target object or its prototype chain.\n   * @param target The target object on which the metadata is defined.\n   * @param propertyKey The property key for the target.\n   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n   * @example\n   *\n   * ```typescript\n   * class Example {\n   *     // property declarations are not part of ES6, though they are valid in TypeScript:\n   *     // static staticProperty;\n   *     // property;\n   *\n   *     static staticMethod(p) { }\n   *     method(p) { }\n   * }\n   *\n   * // on contructor\n   * result = Metadata.getOwnType(Example);\n   *\n   * // property (on constructor)\n   * result = Metadata.getOwnType(Example, \"staticProperty\");\n   *\n   * // method (on constructor)\n   * result = Metadata.getOwnType(Example, \"staticMethod\");\n   * ```\n   *\n   */\n  static getOwnType(target: any, propertyKey?: string | symbol): any {\n    return Reflect.getMetadata(DESIGN_TYPE, target, propertyKey!);\n  }\n\n  /**\n   * Gets the metadata value for the provided metadata DESIGN_RETURN_TYPE on the target object or its prototype chain.\n   * @param target The target object on which the metadata is defined.\n   * @param propertyKey The property key for the target.\n   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n   * @example\n   *\n   * ```typescript\n   * class Example {\n   *     // property declarations are not part of ES6, though they are valid in TypeScript:\n   *     // static staticProperty;\n   *     // property;\n   *\n   *     static staticMethod(p) { }\n   *     method(p) { }\n   * }\n   *\n   * // on contructor\n   * result = Metadata.getReturnType(Example);\n   *\n   * // property (on constructor)\n   * result = Metadata.getReturnType(Example, \"staticProperty\");\n   *\n   * // method (on constructor)\n   * result = Metadata.getReturnType(Example, \"staticMethod\");\n   * ```\n   *\n   */\n  static getReturnType(target: any, propertyKey?: string | symbol): any {\n    return Reflect.getMetadata(DESIGN_RETURN_TYPE, target, propertyKey!);\n  }\n\n  /**\n   * Gets the metadata value for the provided metadata DESIGN_RETURN_TYPE on the target object or its prototype chain.\n   * @param target The target object on which the metadata is defined.\n   * @param propertyKey The property key for the target.\n   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n   * @example\n   *\n   * ```typescript\n   * class Example {\n   *     // property declarations are not part of ES6, though they are valid in TypeScript:\n   *     // static staticProperty;\n   *     // property;\n   *\n   *     static staticMethod(p) { }\n   *     method(p) { }\n   * }\n   *\n   * // on contructor\n   * result = Metadata.getOwnReturnType(Example);\n   *\n   * // property (on constructor)\n   * result = Metadata.getOwnReturnType(Example, \"staticProperty\");\n   *\n   * // method (on constructor)\n   * result = Metadata.getOwnReturnType(Example, \"staticMethod\");\n   * ```\n   *\n   */\n  static getOwnReturnType(target: any, propertyKey?: string | symbol): any {\n    return Reflect.getOwnMetadata(DESIGN_RETURN_TYPE, target, propertyKey!);\n  }\n\n  /**\n   * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.\n   * @param key A key used to store and retrieve metadata.\n   * @param target The target object on which the metadata is defined.\n   * @param propertyKey The property key for the target.\n   * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.\n   * @example\n   *\n   * ```typescript\n   * class Example {\n   *     // property declarations are not part of ES6, though they are valid in TypeScript:\n   *     // static staticProperty;\n   *     // property;\n   *\n   *     static staticMethod(p) { }\n   *     method(p) { }\n   * }\n   *\n   * // constructor\n   * result = Metadata.has(\"custom:annotation\", Example);\n   *\n   * // property (on constructor)\n   * result = Metadata.has(\"custom:annotation\", Example, \"staticProperty\");\n   *\n   * // property (on prototype)\n   * result = Metadata.has(\"custom:annotation\", Example.prototype, \"property\");\n   *\n   * // method (on constructor)\n   * result = Metadata.has(\"custom:annotation\", Example, \"staticMethod\");\n   *\n   * // method (on prototype)\n   * result = Metadata.has(\"custom:annotation\", Example.prototype, \"method\");\n   * ```\n   *\n   */\n  static has(key: string, target: any, propertyKey?: string | symbol): boolean {\n    try {\n      return Reflect.hasMetadata(key, getClass(target), propertyKey!);\n    } catch (er) {}\n\n    return false;\n  }\n\n  /**\n   * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.\n   * @param key A key used to store and retrieve metadata.\n   * @param target The target object on which the metadata is defined.\n   * @param propertyKey The property key for the target.\n   * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.\n   * @example\n   *\n   * ```typescript\n   * class Example {\n   *     // property declarations are not part of ES6, though they are valid in TypeScript:\n   *     // static staticProperty;\n   *     // property;\n   *\n   *     static staticMethod(p) { }\n   *     method(p) { }\n   * }\n   *\n   * // constructor\n   * result = Metadata.has(\"custom:annotation\", Example);\n   *\n   * // property (on constructor)\n   * result = Metadata.hasOwn(\"custom:annotation\", Example, \"staticProperty\");\n   *\n   * // property (on prototype)\n   * result = Metadata.hasOwn(\"custom:annotation\", Example.prototype, \"property\");\n   *\n   * // method (on constructor)\n   * result = Metadata.hasOwn(\"custom:annotation\", Example, \"staticMethod\");\n   *\n   * // method (on prototype)\n   * result = Metadata.hasOwn(\"custom:annotation\", Example.prototype, \"method\");\n   * ```\n   *\n   */\n  static hasOwn(key: string, target: any, propertyKey?: string | symbol): boolean {\n    return Reflect.hasOwnMetadata(key, getClass(target), propertyKey!);\n  }\n\n  /**\n   * Deletes the metadata entry from the target object with the provided key.\n   * @param key A key used to store and retrieve metadata.\n   * @param target The target object on which the metadata is defined.\n   * @param propertyKey The property key for the target.\n   * @returns `true` if the metadata entry was found and deleted; otherwise, false.\n   * @example\n   *\n   * ```typescript\n   * class Example {\n   *     // property declarations are not part of ES6, though they are valid in TypeScript:\n   *     // static staticProperty;\n   *     // property;\n   *\n   *     static staticMethod(p) { }\n   *     method(p) { }\n   * }\n   *\n   * // constructor\n   * result = Metadata.delete(\"custom:annotation\", Example);\n   *\n   * // property (on constructor)\n   * result = Metadata.delete(\"custom:annotation\", Example, \"staticProperty\");\n   *\n   * // property (on prototype)\n   * result = Metadata.delete(\"custom:annotation\", Example.prototype, \"property\");\n   *\n   * // method (on constructor)\n   * result = Metadata.delete(\"custom:annotation\", Example, \"staticMethod\");\n   *\n   * // method (on prototype)\n   * result = Metadata.delete(\"custom:annotation\", Example.prototype, \"method\");\n   * ```\n   *\n   */\n  static delete(key: string, target: any, propertyKey?: string | symbol): boolean {\n    return Reflect.deleteMetadata(key, getClass(target), propertyKey!);\n  }\n\n  /**\n   * Set the metadata value for the provided metadata DESIGN_PARAM_TYPES on the target object or its prototype chain.\n   * @param target The target object on which the metadata is defined.\n   * @param propertyKey The property key for the target.\n   * @param value A value that contains attached metadata.\n   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n   * @example\n   *\n   * ```typescript\n   * class Example {\n   *     // property declarations are not part of ES6, though they are valid in TypeScript:\n   *     // static staticProperty;\n   *     // property;\n   *\n   *     static staticMethod(p) { }\n   *     method(p) { }\n   * }\n   *\n   * // on contructor\n   * result = Metadata.setParamTypes(Example, undefined, [Object]);\n   *\n   * // property (on constructor)\n   * result = Metadata.setParamTypes(Example, \"staticProperty\", [Object]);\n   *\n   * // property (on prototype)\n   * result = Metadata.setParamTypes(Example.prototype, \"property\", [Object]);\n   *\n   * // method (on constructor)\n   * result = Metadata.setParamTypes(Example, \"staticMethod\", [Object]);\n   *\n   * // method (on prototype)\n   * result = Metadata.setParamTypes(Example.prototype, \"method\", [Object]);\n   * ```\n   *\n   */\n  static setParamTypes(target: any, propertyKey: string | symbol, value: any): void {\n    return this.set(DESIGN_PARAM_TYPES, value, target.prototype, propertyKey);\n  }\n\n  /**\n   * Get all metadata for a metadataKey.\n   * @param metadataKey\n   */\n  static getTargetsFromPropertyKey = (metadataKey: string | symbol): any[] =>\n    PROPERTIES.has(metadataKey) ? PROPERTIES.get(metadataKey) || [] : [];\n\n  /**\n   * Define a unique metadata entry on the target.\n   * @param key A key used to store and retrieve metadata.\n   * @param value A value that contains attached metadata.\n   * @param target The target object on which to define metadata.\n   * @param propertyKey The property key for the target.\n   * @example\n   *\n   * ```typescript\n   * class Example {\n   *     // property declarations are not part of ES6, though they are valid in TypeScript:\n   *     // static staticProperty;\n   *     // property;\n   *\n   *     static staticMethod(p) { }\n   *     method(p) { }\n   * }\n   *\n   * // constructor\n   * Reflect.defineMetadata(\"custom:annotation\", options, Example);\n   *\n   * // property (on constructor)\n   * Reflect.defineMetadata(\"custom:annotation\", Number, Example, \"staticProperty\");\n   *\n   * // property (on prototype)\n   * Reflect.defineMetadata(\"custom:annotation\", Number, Example.prototype, \"property\");\n   *\n   * // method (on constructor)\n   * Reflect.defineMetadata(\"custom:annotation\", Number, Example, \"staticMethod\");\n   *\n   * // method (on prototype)\n   * Reflect.defineMetadata(\"custom:annotation\", Number, Example.prototype, \"method\");\n   *\n   * // decorator factory as metadata-producing annotation.\n   * function MyAnnotation(options): PropertyDecorator {\n   *     return (target, key) => Reflect.defineMetadata(\"custom:annotation\", options, target, key);\n   * }\n   * ```\n   *\n   */\n  static set(key: string, value: any, target: any, propertyKey?: string | symbol): void {\n    const targets: any[] = PROPERTIES.has(key) ? PROPERTIES.get(key) || [] : [];\n    const classConstructor = getClass(target);\n\n    if (targets.indexOf(classConstructor) === -1) {\n      targets.push(classConstructor);\n      PROPERTIES.set(key, targets);\n    }\n\n    Reflect.defineMetadata(key, value, getClass(target), propertyKey!);\n  }\n\n  /**\n   * Gets the metadata value for the provided metadata DESIGN_PARAM_TYPES on the target object or its prototype chain.\n   * @param targetPrototype\n   * @param propertyKey The property key for the target.\n   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n   * @example\n   *\n   * ```typescript\n   * class Example {\n   *     // property declarations are not part of ES6, though they are valid in TypeScript:\n   *     // static staticProperty;\n   *     // property;\n   *\n   *     static staticMethod(p) { }\n   *     method(p) { }\n   * }\n   *\n   * // on contructor\n   * result = Metadata.getParamTypes(Example.prototype);\n   *\n   * // property (on constructor)\n   * result = Metadata.getParamTypes(Example.prototype, \"staticProperty\");\n   *\n   * // method (on constructor)\n   * result = Metadata.getParamTypes(Example.prototype, \"staticMethod\");\n   * ```\n   *\n   */\n  static getParamTypes(targetPrototype: any, propertyKey?: string | symbol): any[] {\n    return Reflect.getMetadata(DESIGN_PARAM_TYPES, targetPrototype, propertyKey!) || [];\n  }\n\n  /**\n   * Gets the metadata value for the provided metadata DESIGN_PARAM_TYPES on the target object or its prototype chain.\n   * @param target The target object on which the metadata is defined.\n   * @param propertyKey The property key for the target.\n   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n   * @example\n   *\n   * ```typescript\n   * class Example {\n   *     // property declarations are not part of ES6, though they are valid in TypeScript:\n   *     // static staticProperty;\n   *     // property;\n   *\n   *     static staticMethod(p) { }\n   *     method(p) { }\n   * }\n   *\n   * // on contructor\n   * result = Metadata.getParamTypes(Example);\n   *\n   * // property (on constructor)\n   * result = Metadata.getParamTypes(Example, \"staticProperty\");\n   *\n   * // method (on constructor)\n   * result = Metadata.getParamTypes(Example, \"staticMethod\");\n   * ```\n   *\n   */\n  static getOwnParamTypes(target: any, propertyKey?: string | symbol): any[] {\n    return Reflect.getOwnMetadata(DESIGN_PARAM_TYPES, target, propertyKey!) || [];\n  }\n}\n\n/**\n * Metadata key\n * @private\n * @type {string}\n */\nconst DESIGN_PARAM_TYPES = \"design:paramtypes\";\n/**\n * Metadata key\n * @private\n * @type {string}\n */\nconst DESIGN_TYPE = \"design:type\";\n/**\n * Metadata key\n * @private\n * @type {string}\n */\nconst DESIGN_RETURN_TYPE = \"design:returntype\";\n\n/**\n * Properties collections\n * @private\n * @type {string}\n */\nconst PROPERTIES: Map<string | symbol, any[]> = new Map<string | symbol, any[]>();\n"],"sourceRoot":"../../src"}