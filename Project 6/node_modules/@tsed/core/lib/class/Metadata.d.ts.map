{"version":3,"sources":["class/Metadata.ts"],"names":[],"mappings":"AAAA,OAAO,kBAAkB,CAAC;AAG1B;;GAEG;AACH,qBAAa,QAAQ;IACnB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAkCG;IACH,MAAM,CAAC,GAAG,CAAC,GAAG,EAAE,MAAM,EAAE,MAAM,EAAE,GAAG,EAAE,WAAW,CAAC,EAAE,MAAM,GAAG,MAAM,GAAG,GAAG;IAIxE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAkCG;IACH,MAAM,CAAC,MAAM,CAAC,GAAG,EAAE,MAAM,EAAE,MAAM,EAAE,GAAG,EAAE,WAAW,CAAC,EAAE,MAAM,GAAG,MAAM,GAAG,GAAG;IAI3E;;;;;;;;;;;;;;;;;;;;;;;;;;;OA2BG;IACH,MAAM,CAAC,OAAO,CAAC,MAAM,EAAE,GAAG,EAAE,WAAW,CAAC,EAAE,MAAM,GAAG,MAAM,GAAG,GAAG;IAI/D;;;;;;;;;;;;;;;;;;;;;;;;;;;OA2BG;IACH,MAAM,CAAC,UAAU,CAAC,MAAM,EAAE,GAAG,EAAE,WAAW,CAAC,EAAE,MAAM,GAAG,MAAM,GAAG,GAAG;IAIlE;;;;;;;;;;;;;;;;;;;;;;;;;;;OA2BG;IACH,MAAM,CAAC,aAAa,CAAC,MAAM,EAAE,GAAG,EAAE,WAAW,CAAC,EAAE,MAAM,GAAG,MAAM,GAAG,GAAG;IAIrE;;;;;;;;;;;;;;;;;;;;;;;;;;;OA2BG;IACH,MAAM,CAAC,gBAAgB,CAAC,MAAM,EAAE,GAAG,EAAE,WAAW,CAAC,EAAE,MAAM,GAAG,MAAM,GAAG,GAAG;IAIxE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAkCG;IACH,MAAM,CAAC,GAAG,CAAC,GAAG,EAAE,MAAM,EAAE,MAAM,EAAE,GAAG,EAAE,WAAW,CAAC,EAAE,MAAM,GAAG,MAAM,GAAG,OAAO;IAQ5E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAkCG;IACH,MAAM,CAAC,MAAM,CAAC,GAAG,EAAE,MAAM,EAAE,MAAM,EAAE,GAAG,EAAE,WAAW,CAAC,EAAE,MAAM,GAAG,MAAM,GAAG,OAAO;IAI/E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAkCG;IACH,MAAM,CAAC,MAAM,CAAC,GAAG,EAAE,MAAM,EAAE,MAAM,EAAE,GAAG,EAAE,WAAW,CAAC,EAAE,MAAM,GAAG,MAAM,GAAG,OAAO;IAI/E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAkCG;IACH,MAAM,CAAC,aAAa,CAAC,MAAM,EAAE,GAAG,EAAE,WAAW,EAAE,MAAM,GAAG,MAAM,EAAE,KAAK,EAAE,GAAG,GAAG,IAAI;IAIjF;;;OAGG;IACH,MAAM,CAAC,yBAAyB,0CACuC;IAEvE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAuCG;IACH,MAAM,CAAC,GAAG,CAAC,GAAG,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,EAAE,WAAW,CAAC,EAAE,MAAM,GAAG,MAAM,GAAG,IAAI;IAYrF;;;;;;;;;;;;;;;;;;;;;;;;;;;OA2BG;IACH,MAAM,CAAC,aAAa,CAAC,eAAe,EAAE,GAAG,EAAE,WAAW,CAAC,EAAE,MAAM,GAAG,MAAM,GAAG,GAAG,EAAE;IAIhF;;;;;;;;;;;;;;;;;;;;;;;;;;;OA2BG;IACH,MAAM,CAAC,gBAAgB,CAAC,MAAM,EAAE,GAAG,EAAE,WAAW,CAAC,EAAE,MAAM,GAAG,MAAM,GAAG,GAAG,EAAE;CAG3E","file":"Metadata.d.ts","sourcesContent":["import \"reflect-metadata\";\nimport {getClass} from \"../utils\";\n\n/**\n * @stable\n */\nexport class Metadata {\n  /**\n   * Gets the metadata value for the provided metadata key on the target object or its prototype chain.\n   * @param key A key used to store and retrieve metadata.\n   * @param target The target object on which the metadata is defined.\n   * @param propertyKey The property key for the target.\n   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n   * @example\n   *\n   * ```typescript\n   * class Example {\n   *     // property declarations are not part of ES6, though they are valid in TypeScript:\n   *     // static staticProperty;\n   *     // property;\n   *\n   *     static staticMethod(p) { }\n   *     method(p) { }\n   * }\n   *\n   * // constructor\n   * result = Metadata.get(\"custom:annotation\", Example);\n   *\n   * // property (on constructor)\n   * result = Metadata.get(\"custom:annotation\", Example, \"staticProperty\");\n   *\n   * // property (on prototype)\n   * result = Metadata.get(\"custom:annotation\", Example.prototype, \"property\");\n   *\n   * // method (on constructor)\n   * result = Metadata.get(\"custom:annotation\", Example, \"staticMethod\");\n   *\n   * // method (on prototype)\n   * result = Metadata.get(\"custom:annotation\", Example.prototype, \"method\");\n   * ```\n   *\n   */\n  static get(key: string, target: any, propertyKey?: string | symbol): any {\n    return Reflect.getMetadata(key, getClass(target), propertyKey!);\n  }\n\n  /**\n   * Gets the metadata value for the provided metadata key on the target object or its prototype chain.\n   * @param key A key used to store and retrieve metadata.\n   * @param target The target object on which the metadata is defined.\n   * @param propertyKey The property key for the target.\n   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n   * @example\n   *\n   * ```typescript\n   * class Example {\n   *     // property declarations are not part of ES6, though they are valid in TypeScript:\n   *     // static staticProperty;\n   *     // property;\n   *\n   *     static staticMethod(p) { }\n   *     method(p) { }\n   * }\n   *\n   * // constructor\n   * result = Metadata.getOwn(\"custom:annotation\", Example);\n   *\n   * // property (on constructor)\n   * result = Metadata.getOwn(\"custom:annotation\", Example, \"staticProperty\");\n   *\n   * // property (on prototype)\n   * result = Metadata.getOwn(\"custom:annotation\", Example.prototype, \"property\");\n   *\n   * // method (on constructor)\n   * result = Metadata.getOwn(\"custom:annotation\", Example, \"staticMethod\");\n   *\n   * // method (on prototype)\n   * result = Metadata.getOwn(\"custom:annotation\", Example.prototype, \"method\");\n   * ```\n   *\n   */\n  static getOwn(key: string, target: any, propertyKey?: string | symbol): any {\n    return Reflect.getOwnMetadata(key, getClass(target), propertyKey!);\n  }\n\n  /**\n   * Gets the metadata value for the provided metadata DESIGN_TYPE on the target object or its prototype chain.\n   * @param target The target object on which the metadata is defined.\n   * @param propertyKey The property key for the target.\n   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n   * @example\n   *\n   * ```typescript\n   * class Example {\n   *     // property declarations are not part of ES6, though they are valid in TypeScript:\n   *     // static staticProperty;\n   *     // property;\n   *\n   *     static staticMethod(p) { }\n   *     method(p) { }\n   * }\n   *\n   * // on contructor\n   * result = Metadata.getType(Example);\n   *\n   * // property (on constructor)\n   * result = Metadata.getType(Example, \"staticProperty\");\n   *\n   * // method (on constructor)\n   * result = Metadata.getType(Example, \"staticMethod\");\n   * ```\n   *\n   */\n  static getType(target: any, propertyKey?: string | symbol): any {\n    return Reflect.getMetadata(DESIGN_TYPE, target, propertyKey!);\n  }\n\n  /**\n   * Gets the metadata value for the provided metadata DESIGN_TYPE on the target object or its prototype chain.\n   * @param target The target object on which the metadata is defined.\n   * @param propertyKey The property key for the target.\n   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n   * @example\n   *\n   * ```typescript\n   * class Example {\n   *     // property declarations are not part of ES6, though they are valid in TypeScript:\n   *     // static staticProperty;\n   *     // property;\n   *\n   *     static staticMethod(p) { }\n   *     method(p) { }\n   * }\n   *\n   * // on contructor\n   * result = Metadata.getOwnType(Example);\n   *\n   * // property (on constructor)\n   * result = Metadata.getOwnType(Example, \"staticProperty\");\n   *\n   * // method (on constructor)\n   * result = Metadata.getOwnType(Example, \"staticMethod\");\n   * ```\n   *\n   */\n  static getOwnType(target: any, propertyKey?: string | symbol): any {\n    return Reflect.getMetadata(DESIGN_TYPE, target, propertyKey!);\n  }\n\n  /**\n   * Gets the metadata value for the provided metadata DESIGN_RETURN_TYPE on the target object or its prototype chain.\n   * @param target The target object on which the metadata is defined.\n   * @param propertyKey The property key for the target.\n   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n   * @example\n   *\n   * ```typescript\n   * class Example {\n   *     // property declarations are not part of ES6, though they are valid in TypeScript:\n   *     // static staticProperty;\n   *     // property;\n   *\n   *     static staticMethod(p) { }\n   *     method(p) { }\n   * }\n   *\n   * // on contructor\n   * result = Metadata.getReturnType(Example);\n   *\n   * // property (on constructor)\n   * result = Metadata.getReturnType(Example, \"staticProperty\");\n   *\n   * // method (on constructor)\n   * result = Metadata.getReturnType(Example, \"staticMethod\");\n   * ```\n   *\n   */\n  static getReturnType(target: any, propertyKey?: string | symbol): any {\n    return Reflect.getMetadata(DESIGN_RETURN_TYPE, target, propertyKey!);\n  }\n\n  /**\n   * Gets the metadata value for the provided metadata DESIGN_RETURN_TYPE on the target object or its prototype chain.\n   * @param target The target object on which the metadata is defined.\n   * @param propertyKey The property key for the target.\n   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n   * @example\n   *\n   * ```typescript\n   * class Example {\n   *     // property declarations are not part of ES6, though they are valid in TypeScript:\n   *     // static staticProperty;\n   *     // property;\n   *\n   *     static staticMethod(p) { }\n   *     method(p) { }\n   * }\n   *\n   * // on contructor\n   * result = Metadata.getOwnReturnType(Example);\n   *\n   * // property (on constructor)\n   * result = Metadata.getOwnReturnType(Example, \"staticProperty\");\n   *\n   * // method (on constructor)\n   * result = Metadata.getOwnReturnType(Example, \"staticMethod\");\n   * ```\n   *\n   */\n  static getOwnReturnType(target: any, propertyKey?: string | symbol): any {\n    return Reflect.getOwnMetadata(DESIGN_RETURN_TYPE, target, propertyKey!);\n  }\n\n  /**\n   * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.\n   * @param key A key used to store and retrieve metadata.\n   * @param target The target object on which the metadata is defined.\n   * @param propertyKey The property key for the target.\n   * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.\n   * @example\n   *\n   * ```typescript\n   * class Example {\n   *     // property declarations are not part of ES6, though they are valid in TypeScript:\n   *     // static staticProperty;\n   *     // property;\n   *\n   *     static staticMethod(p) { }\n   *     method(p) { }\n   * }\n   *\n   * // constructor\n   * result = Metadata.has(\"custom:annotation\", Example);\n   *\n   * // property (on constructor)\n   * result = Metadata.has(\"custom:annotation\", Example, \"staticProperty\");\n   *\n   * // property (on prototype)\n   * result = Metadata.has(\"custom:annotation\", Example.prototype, \"property\");\n   *\n   * // method (on constructor)\n   * result = Metadata.has(\"custom:annotation\", Example, \"staticMethod\");\n   *\n   * // method (on prototype)\n   * result = Metadata.has(\"custom:annotation\", Example.prototype, \"method\");\n   * ```\n   *\n   */\n  static has(key: string, target: any, propertyKey?: string | symbol): boolean {\n    try {\n      return Reflect.hasMetadata(key, getClass(target), propertyKey!);\n    } catch (er) {}\n\n    return false;\n  }\n\n  /**\n   * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.\n   * @param key A key used to store and retrieve metadata.\n   * @param target The target object on which the metadata is defined.\n   * @param propertyKey The property key for the target.\n   * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.\n   * @example\n   *\n   * ```typescript\n   * class Example {\n   *     // property declarations are not part of ES6, though they are valid in TypeScript:\n   *     // static staticProperty;\n   *     // property;\n   *\n   *     static staticMethod(p) { }\n   *     method(p) { }\n   * }\n   *\n   * // constructor\n   * result = Metadata.has(\"custom:annotation\", Example);\n   *\n   * // property (on constructor)\n   * result = Metadata.hasOwn(\"custom:annotation\", Example, \"staticProperty\");\n   *\n   * // property (on prototype)\n   * result = Metadata.hasOwn(\"custom:annotation\", Example.prototype, \"property\");\n   *\n   * // method (on constructor)\n   * result = Metadata.hasOwn(\"custom:annotation\", Example, \"staticMethod\");\n   *\n   * // method (on prototype)\n   * result = Metadata.hasOwn(\"custom:annotation\", Example.prototype, \"method\");\n   * ```\n   *\n   */\n  static hasOwn(key: string, target: any, propertyKey?: string | symbol): boolean {\n    return Reflect.hasOwnMetadata(key, getClass(target), propertyKey!);\n  }\n\n  /**\n   * Deletes the metadata entry from the target object with the provided key.\n   * @param key A key used to store and retrieve metadata.\n   * @param target The target object on which the metadata is defined.\n   * @param propertyKey The property key for the target.\n   * @returns `true` if the metadata entry was found and deleted; otherwise, false.\n   * @example\n   *\n   * ```typescript\n   * class Example {\n   *     // property declarations are not part of ES6, though they are valid in TypeScript:\n   *     // static staticProperty;\n   *     // property;\n   *\n   *     static staticMethod(p) { }\n   *     method(p) { }\n   * }\n   *\n   * // constructor\n   * result = Metadata.delete(\"custom:annotation\", Example);\n   *\n   * // property (on constructor)\n   * result = Metadata.delete(\"custom:annotation\", Example, \"staticProperty\");\n   *\n   * // property (on prototype)\n   * result = Metadata.delete(\"custom:annotation\", Example.prototype, \"property\");\n   *\n   * // method (on constructor)\n   * result = Metadata.delete(\"custom:annotation\", Example, \"staticMethod\");\n   *\n   * // method (on prototype)\n   * result = Metadata.delete(\"custom:annotation\", Example.prototype, \"method\");\n   * ```\n   *\n   */\n  static delete(key: string, target: any, propertyKey?: string | symbol): boolean {\n    return Reflect.deleteMetadata(key, getClass(target), propertyKey!);\n  }\n\n  /**\n   * Set the metadata value for the provided metadata DESIGN_PARAM_TYPES on the target object or its prototype chain.\n   * @param target The target object on which the metadata is defined.\n   * @param propertyKey The property key for the target.\n   * @param value A value that contains attached metadata.\n   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n   * @example\n   *\n   * ```typescript\n   * class Example {\n   *     // property declarations are not part of ES6, though they are valid in TypeScript:\n   *     // static staticProperty;\n   *     // property;\n   *\n   *     static staticMethod(p) { }\n   *     method(p) { }\n   * }\n   *\n   * // on contructor\n   * result = Metadata.setParamTypes(Example, undefined, [Object]);\n   *\n   * // property (on constructor)\n   * result = Metadata.setParamTypes(Example, \"staticProperty\", [Object]);\n   *\n   * // property (on prototype)\n   * result = Metadata.setParamTypes(Example.prototype, \"property\", [Object]);\n   *\n   * // method (on constructor)\n   * result = Metadata.setParamTypes(Example, \"staticMethod\", [Object]);\n   *\n   * // method (on prototype)\n   * result = Metadata.setParamTypes(Example.prototype, \"method\", [Object]);\n   * ```\n   *\n   */\n  static setParamTypes(target: any, propertyKey: string | symbol, value: any): void {\n    return this.set(DESIGN_PARAM_TYPES, value, target.prototype, propertyKey);\n  }\n\n  /**\n   * Get all metadata for a metadataKey.\n   * @param metadataKey\n   */\n  static getTargetsFromPropertyKey = (metadataKey: string | symbol): any[] =>\n    PROPERTIES.has(metadataKey) ? PROPERTIES.get(metadataKey) || [] : [];\n\n  /**\n   * Define a unique metadata entry on the target.\n   * @param key A key used to store and retrieve metadata.\n   * @param value A value that contains attached metadata.\n   * @param target The target object on which to define metadata.\n   * @param propertyKey The property key for the target.\n   * @example\n   *\n   * ```typescript\n   * class Example {\n   *     // property declarations are not part of ES6, though they are valid in TypeScript:\n   *     // static staticProperty;\n   *     // property;\n   *\n   *     static staticMethod(p) { }\n   *     method(p) { }\n   * }\n   *\n   * // constructor\n   * Reflect.defineMetadata(\"custom:annotation\", options, Example);\n   *\n   * // property (on constructor)\n   * Reflect.defineMetadata(\"custom:annotation\", Number, Example, \"staticProperty\");\n   *\n   * // property (on prototype)\n   * Reflect.defineMetadata(\"custom:annotation\", Number, Example.prototype, \"property\");\n   *\n   * // method (on constructor)\n   * Reflect.defineMetadata(\"custom:annotation\", Number, Example, \"staticMethod\");\n   *\n   * // method (on prototype)\n   * Reflect.defineMetadata(\"custom:annotation\", Number, Example.prototype, \"method\");\n   *\n   * // decorator factory as metadata-producing annotation.\n   * function MyAnnotation(options): PropertyDecorator {\n   *     return (target, key) => Reflect.defineMetadata(\"custom:annotation\", options, target, key);\n   * }\n   * ```\n   *\n   */\n  static set(key: string, value: any, target: any, propertyKey?: string | symbol): void {\n    const targets: any[] = PROPERTIES.has(key) ? PROPERTIES.get(key) || [] : [];\n    const classConstructor = getClass(target);\n\n    if (targets.indexOf(classConstructor) === -1) {\n      targets.push(classConstructor);\n      PROPERTIES.set(key, targets);\n    }\n\n    Reflect.defineMetadata(key, value, getClass(target), propertyKey!);\n  }\n\n  /**\n   * Gets the metadata value for the provided metadata DESIGN_PARAM_TYPES on the target object or its prototype chain.\n   * @param targetPrototype\n   * @param propertyKey The property key for the target.\n   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n   * @example\n   *\n   * ```typescript\n   * class Example {\n   *     // property declarations are not part of ES6, though they are valid in TypeScript:\n   *     // static staticProperty;\n   *     // property;\n   *\n   *     static staticMethod(p) { }\n   *     method(p) { }\n   * }\n   *\n   * // on contructor\n   * result = Metadata.getParamTypes(Example.prototype);\n   *\n   * // property (on constructor)\n   * result = Metadata.getParamTypes(Example.prototype, \"staticProperty\");\n   *\n   * // method (on constructor)\n   * result = Metadata.getParamTypes(Example.prototype, \"staticMethod\");\n   * ```\n   *\n   */\n  static getParamTypes(targetPrototype: any, propertyKey?: string | symbol): any[] {\n    return Reflect.getMetadata(DESIGN_PARAM_TYPES, targetPrototype, propertyKey!) || [];\n  }\n\n  /**\n   * Gets the metadata value for the provided metadata DESIGN_PARAM_TYPES on the target object or its prototype chain.\n   * @param target The target object on which the metadata is defined.\n   * @param propertyKey The property key for the target.\n   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n   * @example\n   *\n   * ```typescript\n   * class Example {\n   *     // property declarations are not part of ES6, though they are valid in TypeScript:\n   *     // static staticProperty;\n   *     // property;\n   *\n   *     static staticMethod(p) { }\n   *     method(p) { }\n   * }\n   *\n   * // on contructor\n   * result = Metadata.getParamTypes(Example);\n   *\n   * // property (on constructor)\n   * result = Metadata.getParamTypes(Example, \"staticProperty\");\n   *\n   * // method (on constructor)\n   * result = Metadata.getParamTypes(Example, \"staticMethod\");\n   * ```\n   *\n   */\n  static getOwnParamTypes(target: any, propertyKey?: string | symbol): any[] {\n    return Reflect.getOwnMetadata(DESIGN_PARAM_TYPES, target, propertyKey!) || [];\n  }\n}\n\n/**\n * Metadata key\n * @private\n * @type {string}\n */\nconst DESIGN_PARAM_TYPES = \"design:paramtypes\";\n/**\n * Metadata key\n * @private\n * @type {string}\n */\nconst DESIGN_TYPE = \"design:type\";\n/**\n * Metadata key\n * @private\n * @type {string}\n */\nconst DESIGN_RETURN_TYPE = \"design:returntype\";\n\n/**\n * Properties collections\n * @private\n * @type {string}\n */\nconst PROPERTIES: Map<string | symbol, any[]> = new Map<string | symbol, any[]>();\n"],"sourceRoot":"../../src"}