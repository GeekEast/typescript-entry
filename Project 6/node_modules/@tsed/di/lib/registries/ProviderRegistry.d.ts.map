{"version":3,"sources":["registries/ProviderRegistry.ts"],"names":[],"mappings":"AACA,OAAO,EAAC,SAAS,EAA8B,MAAM,eAAe,CAAC;AAgCrE;;;GAGG;AACH,wBAAgB,gBAAgB,CAAC,QAAQ,EAAE,OAAO,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAMxE;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA8DG;AACH,eAAO,MAAM,eAAe,yCAkB3B,CAAC;AAEF;;;;;;;;;;;;;;;;;;;;GAoBG;AACH,eAAO,MAAM,aAAa,sCAgBzB,CAAC;AAEF;;;;;;;;;;;;;;;;;;;;;;;;;;;GA2BG;AACH,eAAO,MAAM,eAAe,yCAAyD,CAAC;AACtF;;;;;;;;;;;;;;;;;;;;;;;;;;;GA2BG;AACH,eAAO,MAAM,kBAAkB,yCAA4D,CAAC;AAC5F;;;;;;;;;;;;;;;;;;;;;;;;;;GA0BG;AACH,eAAO,MAAM,mBAAmB,yCAA6D,CAAC","file":"ProviderRegistry.d.ts","sourcesContent":["import {Provider} from \"../class/Provider\";\nimport {IProvider, ProviderScope, ProviderType} from \"../interfaces\";\nimport {GlobalProviders} from \"./GlobalProviders\";\n\n/**\n *\n * @type {GlobalProviderRegistry}\n */\n// tslint:disable-next-line: variable-name\nGlobalProviders.getRegistry(ProviderType.PROVIDER);\n/**\n *\n * @type {Registry<Provider<any>, IProvider<any>>}\n */\nGlobalProviders.createRegistry(ProviderType.SERVICE, Provider);\n/**\n *`\n * @type {Registry<Provider<any>, IProvider<any>>}\n */\nGlobalProviders.createRegistry(ProviderType.FACTORY, Provider);\n\n/**\n *\n * @type {Registry<Provider<any>, IProvider<any>>}\n */\nGlobalProviders.createRegistry(ProviderType.INTERCEPTOR, Provider);\n/**\n *\n */\nGlobalProviders.createRegistry(ProviderType.CONTROLLER, Provider, {\n  injectable: false\n});\n\n/**\n * Register a provider configuration.\n * @param {IProvider<any>} provider\n */\nexport function registerProvider(provider: Partial<IProvider<any>>): void {\n  if (!provider.provide) {\n    throw new Error(\"Provider.provide is required\");\n  }\n\n  GlobalProviders.merge(provider.provide, provider);\n}\n\n/**\n * Add a new factory in the `ProviderRegistry`.\n *\n * #### Example with symbol definition\n *\n *\n * ```typescript\n * import {registerFactory, InjectorService} from \"@tsed/common\";\n *\n * export interface IMyFooFactory {\n *    getFoo(): string;\n * }\n *\n * export type MyFooFactory = IMyFooFactory;\n * export const MyFooFactory = Symbol(\"MyFooFactory\");\n *\n * registerFactory(MyFooFactory, {\n *      getFoo:  () => \"test\"\n * });\n *\n * // or\n *\n * registerFactory({provide: MyFooFactory, instance: {\n *      getFoo:  () => \"test\"\n * }});\n *\n * @Service()\n * export class OtherService {\n *      constructor(@Inject(MyFooFactory) myFooFactory: MyFooFactory){\n *          console.log(myFooFactory.getFoo()); /// \"test\"\n *      }\n * }\n * ```\n *\n * > Note: When you use the factory method with Symbol definition, you must use the `@Inject()`\n * decorator to retrieve your factory in another Service. Advice: By convention all factory class name will be prefixed by\n * `Factory`.\n *\n * #### Example with class\n *\n * ```typescript\n * import {InjectorService, registerFactory} from \"@tsed/common\";\n *\n * export class MyFooService {\n *  constructor(){}\n *      getFoo() {\n *          return \"test\";\n *      }\n * }\n *\n * registerFactory(MyFooService, new MyFooService());\n * // or\n * registerFactory({provider: MyFooService, instance: new MyFooService()});\n *\n * @Service()\n * export class OtherService {\n *      constructor(myFooService: MyFooService){\n *          console.log(myFooFactory.getFoo()); /// \"test\"\n *      }\n * }\n * ```\n *\n */\nexport const registerFactory = (provider: any | IProvider<any>, instance?: any): void => {\n  if (!provider.provide) {\n    provider = {\n      provide: provider\n    };\n  }\n\n  provider = Object.assign(\n    {\n      scope: ProviderScope.SINGLETON,\n      useFactory() {\n        return instance;\n      }\n    },\n    provider,\n    {type: ProviderType.FACTORY}\n  );\n  GlobalProviders.getRegistry(ProviderType.FACTORY).merge(provider.provide, provider);\n};\n\n/**\n * Add a new value in the `ProviderRegistry`.\n *\n * #### Example with symbol definition\n *\n *\n * ```typescript\n * import {registerValue, InjectorService} from \"@tsed/common\";\n *\n * const MyValue = Symbol.from(\"MyValue\")\n *\n * registerValue(MyValue, \"myValue\");\n *\n * @Service()\n * export class OtherService {\n *      constructor(@Inject(MyValue) myValue: string){\n *          console.log(myValue); /// \"myValue\"\n *      }\n * }\n * ```\n */\nexport const registerValue = (provider: any | IProvider<any>, value?: any): void => {\n  if (!provider.provide) {\n    provider = {\n      provide: provider\n    };\n  }\n\n  provider = Object.assign(\n    {\n      scope: ProviderScope.SINGLETON,\n      useValue: value\n    },\n    provider,\n    {type: ProviderType.VALUE}\n  );\n  GlobalProviders.getRegistry(ProviderType.VALUE).merge(provider.provide, provider);\n};\n\n/**\n * Add a new service in the `ProviderRegistry`. This service will be built when `InjectorService` will be loaded.\n *\n * #### Example\n *\n * ```typescript\n * import {registerService, InjectorService} from \"@tsed/common\";\n *\n * export default class MyFooService {\n *     constructor(){}\n *     getFoo() {\n *         return \"test\";\n *     }\n * }\n *\n * registerService({provide: MyFooService});\n * // or\n * registerService(MyFooService);\n *\n * const injector = new InjectorService();\n * injector.load();\n *\n * const myFooService = injector.get<MyFooService>(MyFooService);\n * myFooService.getFoo(); // test\n * ```\n *\n * @param provider Provider configuration.\n */\nexport const registerService = GlobalProviders.createRegisterFn(ProviderType.SERVICE);\n/**\n * Add a new controller in the `ProviderRegistry`. This controller will be built when `InjectorService` will be loaded.\n *\n * #### Example\n *\n * ```typescript\n * import {registerController, InjectorService} from \"@tsed/common\";\n *\n * export default class MyController {\n *     constructor(){}\n *     transform() {\n *         return \"test\";\n *     }\n * }\n *\n * registerController({provide: MyController});\n * // or\n * registerController(MyController);\n *\n * const injector = new InjectorService();\n * injector.load();\n *\n * const myController = injector.get<MyController>(MyController);\n * myController.getFoo(); // test\n * ```\n *\n * @param provider Provider configuration.\n */\nexport const registerController = GlobalProviders.createRegisterFn(ProviderType.CONTROLLER);\n/**\n * Add a new interceptor in the `ProviderRegistry`. This interceptor will be built when `InjectorService` will be loaded.\n *\n * #### Example\n *\n * ```typescript\n * import {registerInterceptor, InjectorService} from \"@tsed/common\";\n *\n * export default class MyInterceptor {\n *     intercept() {\n *         return \"test\";\n *     }\n * }\n *\n * registerInterceptor({provide: MyInterceptor});\n * // or\n * registerInterceptor(MyInterceptor);\n *\n * const injector = new InjectorService()\n * injector.load();\n *\n * const myInterceptor = injector.get<MyInterceptor>(MyInterceptor);\n * myInterceptor.intercept(); // test\n * ```\n *\n * @param provider Provider configuration.\n */\nexport const registerInterceptor = GlobalProviders.createRegisterFn(ProviderType.INTERCEPTOR);\n"],"sourceRoot":"../../src"}