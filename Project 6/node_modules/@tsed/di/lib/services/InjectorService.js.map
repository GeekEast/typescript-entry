{"version":3,"sources":["services/InjectorService.ts"],"names":[],"mappings":"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","file":"InjectorService.js","sourcesContent":["import {deepClone, getClass, getClassOrSymbol, isFunction, Metadata, nameOf, prototypeOf, Store} from \"@tsed/core\";\nimport * as util from \"util\";\nimport {Container} from \"../class/Container\";\nimport {LocalsContainer} from \"../class/LocalsContainer\";\nimport {Provider} from \"../class/Provider\";\nimport {Injectable} from \"../decorators/injectable\";\nimport {InjectionError} from \"../errors/InjectionError\";\nimport {UndefinedTokenError} from \"../errors/UndefinedTokenError\";\nimport {\n  IDILogger,\n  IDISettings,\n  IInjectableProperties,\n  IInjectablePropertyService,\n  IInjectablePropertyValue,\n  IInterceptor,\n  IInterceptorContext,\n  IInvokeOptions,\n  InjectablePropertyType,\n  ProviderScope,\n  TokenProvider\n} from \"../interfaces\";\nimport {GlobalProviders} from \"../registries/GlobalProviders\";\n\ninterface IInvokeSettings {\n  token: TokenProvider;\n  parent?: TokenProvider;\n  scope: ProviderScope;\n  useScope: boolean;\n  isBindable: boolean;\n  deps: any[];\n\n  construct(deps: TokenProvider[]): any;\n}\n\n/**\n * This service contain all services collected by `@Service` or services declared manually with `InjectorService.factory()` or `InjectorService.service()`.\n *\n * ### Example:\n *\n * ```typescript\n * import {InjectorService} from \"@tsed/common\";\n *\n * // Import the services (all services are decorated with @Service()\";\n * import MyService1 from \"./services/service1\";\n * import MyService2 from \"./services/service2\";\n * import MyService3 from \"./services/service3\";\n *\n * // When all services is imported you can load InjectorService.\n * const injector = new InjectorService()\n * injector.load();\n *\n * const myService1 = injector.get<MyService1>(MyServcice1);\n * ```\n *\n * > Note: `ServerLoader` make this automatically when you use `ServerLoader.mount()` method (or settings attributes) and load services and controllers during the starting server.\n *\n */\n@Injectable({\n  scope: ProviderScope.SINGLETON,\n  global: true\n})\nexport class InjectorService extends Container {\n  public settings: IDISettings = new Map();\n  public logger: IDILogger = console;\n  public scopes: {[key: string]: ProviderScope} = {};\n\n  constructor() {\n    super();\n    const provider = this.addProvider(InjectorService).getProvider(InjectorService)!;\n    provider.instance = this;\n  }\n\n  /**\n   * Retrieve default scope for a given provider.\n   * @param provider\n   */\n  public scopeOf(provider: Provider<any>) {\n    return provider.scope || this.scopes[provider.type] || ProviderScope.SINGLETON;\n  }\n\n  /**\n   * Clone a provider from GlobalProviders and the given token. forkProvider method build automatically the provider if the instance parameter ins't given.\n   * @param token\n   * @param instance\n   */\n  public /* async */ forkProvider(token: TokenProvider, instance?: any): Provider<any> {\n    const provider = this.addProvider(token).getProvider(token)!;\n\n    if (!instance) {\n      instance = /* await */ this.invoke(token);\n    }\n\n    provider.instance = instance;\n\n    return provider;\n  }\n\n  /**\n   * Return a list of instance build by the injector.\n   */\n  public toArray(): any[] {\n    return super.toArray().map(provider => provider.instance);\n  }\n\n  /**\n   * Get a service or factory already constructed from his symbol or class.\n   *\n   * #### Example\n   *\n   * ```typescript\n   * import {InjectorService} from \"@tsed/common\";\n   * import MyService from \"./services\";\n   *\n   * class OtherService {\n   *      constructor(injectorService: InjectorService) {\n   *          const myService = injectorService.get<MyService>(MyService);\n   *      }\n   * }\n   * ```\n   *\n   * @param token The class or symbol registered in InjectorService.\n   * @returns {boolean}\n   */\n  get<T>(token: TokenProvider): T | undefined {\n    return (super.has(token) && super.get(getClassOrSymbol(token))!.instance) || undefined;\n  }\n\n  /**\n   * The has() method returns a boolean indicating whether an element with the specified key exists or not.\n   * @returns {boolean}\n   * @param token\n   */\n  has(token: TokenProvider): boolean {\n    return super.has(getClassOrSymbol(token)) && !!this.get(token);\n  }\n\n  /**\n   * Invoke the class and inject all services that required by the class constructor.\n   *\n   * #### Example\n   *\n   * ```typescript\n   * import {InjectorService} from \"@tsed/common\";\n   * import MyService from \"./services\";\n   *\n   * class OtherService {\n   *     constructor(injectorService: InjectorService) {\n   *          const myService = injectorService.invoke<MyService>(MyService);\n   *      }\n   *  }\n   * ```\n   *\n   * @param token The injectable class to invoke. Class parameters are injected according constructor signature.\n   * @param locals  Optional object. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.\n   * @param options\n   * @returns {T} The class constructed.\n   */\n  public /* async */ invoke<T>(\n    token: TokenProvider,\n    locals: Map<TokenProvider, any> = new LocalsContainer(),\n    options: Partial<IInvokeOptions<T>> = {}\n  ): T {\n    const provider = this.getProvider(token);\n    let instance: any;\n\n    if (locals.has(token)) {\n      instance = locals.get(token);\n    } else if (!provider || options.rebuild) {\n      instance = /* await */ this._invoke(token, locals, options);\n    } else {\n      switch (this.scopeOf(provider)) {\n        case ProviderScope.SINGLETON:\n          if (!this.has(token)) {\n            provider.instance = /* await */ this._invoke(token, locals, options);\n          }\n\n          instance = this.get<T>(token)!;\n          break;\n\n        case ProviderScope.REQUEST:\n          instance = /* await */ this._invoke(token, locals, options);\n          locals.set(token, instance);\n          break;\n\n        case ProviderScope.INSTANCE:\n          instance = /* await */ this._invoke(provider.provide, locals, options);\n          break;\n      }\n    }\n\n    return instance;\n  }\n\n  /**\n   * Build all providers from GlobalProviders or from given providers parameters and emit `$onInit` event.\n   *\n   * @param container\n   */\n  async load(container: Map<TokenProvider, Provider<any>> = GlobalProviders): Promise<LocalsContainer<any>> {\n    const locals = new LocalsContainer();\n\n    // Clone all providers in the container\n    container.forEach((provider, token) => {\n      if (!this.hasProvider(token)) {\n        this.setProvider(token, provider.clone());\n      }\n    });\n\n    const providers = super.toArray();\n\n    for (const provider of providers) {\n      if (!locals.has(provider.provide) && this.scopeOf(provider) === ProviderScope.SINGLETON) {\n        /* await */\n        this.invoke(provider.provide, locals);\n      }\n\n      if (provider.instance) {\n        locals.set(provider.provide, provider.instance);\n      }\n    }\n\n    await locals.emit(\"$onInit\");\n\n    return locals;\n  }\n\n  /**\n   *\n   * @param instance\n   */\n  public bindInjectableProperties(instance: any) {\n    const store = Store.from(getClass(instance));\n\n    if (store && store.has(\"injectableProperties\")) {\n      const properties: IInjectableProperties = store.get(\"injectableProperties\") || [];\n\n      Object.keys(properties)\n        .map(key => properties[key])\n        .forEach(definition => {\n          switch (definition.bindingType) {\n            case InjectablePropertyType.METHOD:\n              this.bindMethod(instance, definition);\n              break;\n            case InjectablePropertyType.PROPERTY:\n              this.bindProperty(instance, definition);\n              break;\n            case InjectablePropertyType.CONSTANT:\n              this.bindConstant(instance, definition);\n              break;\n            case InjectablePropertyType.VALUE:\n              this.bindValue(instance, definition);\n              break;\n            case InjectablePropertyType.INTERCEPTOR:\n              this.bindInterceptor(instance, definition);\n              break;\n          }\n        });\n    }\n  }\n\n  /**\n   *\n   * @param instance\n   * @param {string} propertyKey\n   */\n  public bindMethod(instance: any, {propertyKey}: IInjectablePropertyService) {\n    const target = getClass(instance);\n    const originalMethod = instance[propertyKey];\n    const deps = Metadata.getParamTypes(prototypeOf(target), propertyKey);\n\n    instance[propertyKey] = () => {\n      const services = deps.map((dependency: any) => this.get(dependency));\n\n      return originalMethod.call(instance, ...services);\n    };\n  }\n\n  /**\n   *\n   * @param instance\n   * @param {string} propertyKey\n   * @param {any} useType\n   */\n  public bindProperty(instance: any, {propertyKey, useType}: IInjectablePropertyService) {\n    Object.defineProperty(instance, propertyKey, {\n      get: () => {\n        return this.get(useType);\n      }\n    });\n  }\n\n  /**\n   *\n   * @param instance\n   * @param {string} propertyKey\n   * @param {any} useType\n   */\n  public bindValue(instance: any, {propertyKey, expression, defaultValue}: IInjectablePropertyValue) {\n    const descriptor = {\n      get: () => this.settings.get(expression) || defaultValue,\n      set: (value: any) => this.settings.set(expression, value),\n      enumerable: true,\n      configurable: true\n    };\n    Object.defineProperty(instance, propertyKey, descriptor);\n  }\n\n  /**\n   *\n   * @param instance\n   * @param {string} propertyKey\n   * @param {any} useType\n   */\n  public bindConstant(instance: any, {propertyKey, expression, defaultValue}: IInjectablePropertyValue) {\n    const clone = (o: any) => {\n      if (o) {\n        return Object.freeze(deepClone(o));\n      }\n\n      return defaultValue;\n    };\n\n    const descriptor = {\n      get: () => clone(this.settings.get(expression)),\n\n      enumerable: true,\n      configurable: true\n    };\n    Object.defineProperty(instance, propertyKey, descriptor);\n\n    return descriptor;\n  }\n\n  /**\n   *\n   * @param instance\n   * @param propertyKey\n   * @param useType\n   * @param options\n   */\n  public bindInterceptor(instance: any, {propertyKey, useType, options}: IInjectablePropertyService) {\n    const target = getClass(instance);\n    const originalMethod = instance[propertyKey];\n\n    instance[propertyKey] = (...args: any[]) => {\n      const next = (err?: Error) => {\n        if (!err) {\n          return originalMethod.apply(instance, args);\n        }\n\n        throw err;\n      };\n\n      const context: IInterceptorContext<any> = {\n        target,\n        method: propertyKey,\n        propertyKey,\n        args,\n        options,\n        proceed: util.deprecate(next, \"context.proceed() is deprecated. Use context.next() or next() parameters instead.\"),\n        next\n      };\n\n      const interceptor = this.get<IInterceptor>(useType)!;\n\n      if (interceptor.aroundInvoke) {\n        interceptor.aroundInvoke = util.deprecate(\n          interceptor.aroundInvoke.bind(interceptor),\n          \"interceptor.aroundInvoke is deprecated. Use interceptor.intercept instead.\"\n        );\n\n        return interceptor.aroundInvoke!(context, options);\n      }\n\n      return interceptor.intercept!(\n        {\n          ...context,\n          options\n        },\n        next\n      );\n    };\n  }\n\n  /**\n   * Invoke a class method and inject service.\n   *\n   * #### IInjectableMethod options\n   *\n   * * **target**: Optional. The class instance.\n   * * **methodName**: `string` Optional. The method name.\n   * * **designParamTypes**: `any[]` Optional. List of injectable types.\n   * * **locals**: `Map<Function, any>` Optional. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.\n   *\n   * #### Example\n   *\n   * @param target\n   * @param locals\n   * @param options\n   * @private\n   */\n  private /* async */ _invoke<T>(\n    target: TokenProvider,\n    locals: Map<TokenProvider, any>,\n    options: Partial<IInvokeOptions<T>> = {}\n  ): Promise<T> {\n    const {token, deps, construct, isBindable} = this.mapInvokeOptions(target, options);\n    const provider = this.getProvider(target);\n\n    if (provider) {\n      if (!provider.injectable && options.parent) {\n        throw new InjectionError(token, `${nameOf(token)} ${provider.type} is not injectable to another provider`);\n      }\n\n      const {onInvoke} = GlobalProviders.getRegistrySettings(target);\n      if (onInvoke) {\n        onInvoke(provider, locals, deps);\n      }\n    }\n\n    let instance: any;\n\n    try {\n      const services = [];\n      for (const dependency of deps) {\n        const service = /* await */ this.invoke(dependency, locals, {parent: token});\n        services.push(service);\n      }\n\n      instance = construct(services);\n    } catch (error) {\n      throw new InjectionError(token, error);\n    }\n\n    if (instance === undefined) {\n      throw new InjectionError(\n        token,\n        `Unable to create new instance from undefined value. Check your provider declaration for ${nameOf(token)}`\n      );\n    }\n\n    if (instance && isBindable) {\n      this.bindInjectableProperties(instance);\n    }\n\n    return instance;\n  }\n\n  /**\n   * Create options to invoke a provider or class.\n   * @param token\n   * @param options\n   */\n  private mapInvokeOptions(token: TokenProvider, options: Partial<IInvokeOptions<any>>): IInvokeSettings {\n    const {useScope = false} = options;\n    let deps: TokenProvider[] | undefined = options.deps;\n    let scope = options.scope;\n    let construct = (deps: TokenProvider[]) => new token(...deps);\n    let isBindable = false;\n\n    if (!token) {\n      throw new UndefinedTokenError();\n    }\n\n    if (this.hasProvider(token)) {\n      const provider = this.getProvider(token)!;\n\n      scope = scope || this.scopeOf(provider);\n      deps = deps || provider.deps;\n\n      if (provider.useValue) {\n        construct = () => (isFunction(provider.useValue) ? provider.useValue() : provider.useValue);\n      } else if (provider.useFactory) {\n        construct = (deps: TokenProvider[]) => provider.useFactory(...deps);\n      } else if (provider.useClass) {\n        isBindable = true;\n        deps = deps || Metadata.getParamTypes(provider.useClass);\n        construct = (deps: TokenProvider[]) => new provider.useClass(...deps);\n      }\n    } else {\n      deps = deps || Metadata.getParamTypes(token);\n    }\n\n    return {\n      token,\n      scope: scope || Store.from(token).get(\"scope\") || ProviderScope.SINGLETON,\n      deps: deps! || [],\n      useScope,\n      isBindable,\n      construct\n    };\n  }\n}\n"],"sourceRoot":"../../src"}