{"version":3,"sources":["mvc/registries/EndpointRegistry.ts"],"names":[],"mappings":"AAAA,OAAO,EAA4C,KAAK,EAAE,IAAI,EAAC,MAAM,YAAY,CAAC;AAClF,OAAO,EAAC,gBAAgB,EAAC,MAAM,2BAA2B,CAAC;AAE3D;;GAEG;AACH,qBAAa,gBAAgB;IAC3B;;;;OAIG;IACH,MAAM,CAAC,eAAe,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC;IAQxC;;;;OAIG;IACH,MAAM,CAAC,YAAY,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,GAAG,gBAAgB,EAAE;IAI1D;;;;OAIG;IACH,MAAM,CAAC,YAAY,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC;IAIrC;;;;OAIG;IACH,MAAM,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,MAAM,EAAE,MAAM,GAAG,MAAM,GAAG,gBAAgB;IAUxE;;;;OAIG;IACH,MAAM,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,MAAM,EAAE,MAAM,GAAG,MAAM,GAAG,OAAO;IAI/D;;;;;OAKG;IACH,MAAM,CAAC,SAAS,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,SAAS,EAAE,MAAM,GAAG,MAAM,EAAE,IAAI,EAAE,GAAG,EAAE;IAM3E;;;;;;OAMG;IACH,MAAM,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,SAAS,EAAE,MAAM,GAAG,MAAM,EAAE,IAAI,EAAE,GAAG,EAAE;IAMrE;;;;;OAKG;IACH,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,SAAS,EAAE,MAAM,GAAG,MAAM,EAAE,IAAI,EAAE,GAAG,EAAE;IAM1E;;;;;OAKG;IACH,MAAM,CAAC,KAAK,CAAC,MAAM,EAAE,GAAG,EAAE,WAAW,EAAE,MAAM,GAAG,KAAK;IAIrD;;;OAGG;IACH,OAAO,CAAC,MAAM,CAAC,OAAO;CAgBvB","file":"EndpointRegistry.d.ts","sourcesContent":["import {descriptorOf, getInheritedClass, Metadata, Store, Type} from \"@tsed/core\";\nimport {EndpointMetadata} from \"../class/EndpointMetadata\";\n\n/**\n * Registry for all Endpoint collected on a provide.\n */\nexport class EndpointRegistry {\n  /**\n   * Return all endpoints from the given class. This method doesn't return the endpoints from the parent of the given class.\n   * @param {Type<any>} target\n   * @returns {any}\n   */\n  static getOwnEndpoints(target: Type<any>) {\n    if (!this.hasEndpoints(target)) {\n      Metadata.set(\"endpoints\", [], target);\n    }\n\n    return Metadata.getOwn(\"endpoints\", target);\n  }\n\n  /**\n   * Get all endpoints from a given class and his parents.\n   * @param {Type<any>} target\n   * @returns {EndpointMetadata[]}\n   */\n  static getEndpoints(target: Type<any>): EndpointMetadata[] {\n    return this.getOwnEndpoints(target).concat(this.inherit(target));\n  }\n\n  /**\n   * Gets a value indicating whether the target object or its prototype chain has endpoints.\n   * @param {Type<any>} target\n   * @returns {boolean}\n   */\n  static hasEndpoints(target: Type<any>) {\n    return Metadata.hasOwn(\"endpoints\", target);\n  }\n\n  /**\n   * Get an endpoint.\n   * @param target\n   * @param method\n   */\n  static get(target: Type<any>, method: string | symbol): EndpointMetadata {\n    if (!this.has(target, method)) {\n      const endpoint = new EndpointMetadata(target, method);\n      this.getOwnEndpoints(target).push(endpoint);\n      Metadata.set(\"endpoints\", endpoint, target, method);\n    }\n\n    return Metadata.getOwn(\"endpoints\", target, method);\n  }\n\n  /**\n   * Gets a value indicating whether the target object or its prototype chain has already method registered.\n   * @param target\n   * @param method\n   */\n  static has(target: Type<any>, method: string | symbol): boolean {\n    return Metadata.hasOwn(\"endpoints\", target, method);\n  }\n\n  /**\n   * Append mvc in the pool (before).\n   * @param target\n   * @param targetKey\n   * @param args\n   */\n  static useBefore(target: Type<any>, targetKey: string | symbol, args: any[]) {\n    this.get(target, targetKey).before(args);\n\n    return this;\n  }\n\n  /**\n   * Add middleware and configuration for the endpoint.\n   * @param target\n   * @param targetKey\n   * @param args\n   * @returns {Endpoint}\n   */\n  static use(target: Type<any>, targetKey: string | symbol, args: any[]) {\n    this.get(target, targetKey).merge(args);\n\n    return this;\n  }\n\n  /**\n   * Append mvc in the pool (after).\n   * @param target\n   * @param targetKey\n   * @param args\n   */\n  static useAfter(target: Type<any>, targetKey: string | symbol, args: any[]) {\n    this.get(target, targetKey).after(args);\n\n    return this;\n  }\n\n  /**\n   * Store a data on store manager.\n   * @param target\n   * @param propertyKey\n   * @returns {any}\n   */\n  static store(target: any, propertyKey: string): Store {\n    return Store.from(target, propertyKey, descriptorOf(target, propertyKey));\n  }\n\n  /**\n   * Retrieve all endpoints from inherited class and store it in the registry.\n   * @param {Type<any>} ctrlClass\n   */\n  private static inherit(ctrlClass: Type<any>) {\n    const endpoints: EndpointMetadata[] = [];\n    let inheritedClass = getInheritedClass(ctrlClass);\n\n    while (inheritedClass && EndpointRegistry.hasEndpoints(inheritedClass)) {\n      this.getOwnEndpoints(inheritedClass).forEach((endpointInheritedClass: EndpointMetadata) => {\n        const endpoint = endpointInheritedClass.inherit(ctrlClass);\n\n        endpoints.push(endpoint);\n      });\n\n      inheritedClass = getInheritedClass(inheritedClass);\n    }\n\n    return endpoints;\n  }\n}\n"],"sourceRoot":"../../../src"}