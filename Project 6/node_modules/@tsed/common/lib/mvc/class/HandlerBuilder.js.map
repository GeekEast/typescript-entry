{"version":3,"sources":["mvc/class/HandlerBuilder.ts"],"names":[],"mappings":"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","file":"HandlerBuilder.js","sourcesContent":["import {isFunction, isPromise, isStream, nameOf} from \"@tsed/core\";\nimport {InjectorService} from \"@tsed/di\";\nimport * as Express from \"express\";\nimport {isObservable} from \"rxjs\";\nimport {FilterBuilder, IFilterPreHandler, ParamMetadata} from \"../../filters\";\nimport {HandlerType} from \"../interfaces/HandlerType\";\nimport {EndpointMetadata} from \"./EndpointMetadata\";\nimport {HandlerMetadata, IHandlerOptions} from \"./HandlerMetadata\";\n\n/**\n * @stable\n */\nexport class HandlerBuilder {\n  private filters: any[];\n  private debug: boolean;\n  private injector: InjectorService;\n\n  constructor(private handlerMetadata: HandlerMetadata) {}\n\n  /**\n   *\n   * @param obj\n   * @returns {HandlerBuilder}\n   */\n  static from(obj: any | EndpointMetadata) {\n    return {\n      build(injector: InjectorService) {\n        const handlerMetadata = HandlerBuilder.resolve(obj, injector);\n\n        if (handlerMetadata.type === HandlerType.FUNCTION) {\n          // injector.logger.debug(\"Return handler as function\", handlerMetadata.handler.name);\n          return handlerMetadata.handler;\n        }\n\n        // injector.logger.trace(\"Build handler\", `${nameOf(handlerMetadata.target)}.${handlerMetadata.method}()`);\n        return new HandlerBuilder(handlerMetadata).build(injector);\n      }\n    };\n  }\n\n  static resolve(obj: any | EndpointMetadata, injector: InjectorService) {\n    let options: IHandlerOptions;\n\n    if (obj instanceof EndpointMetadata) {\n      const provider = injector.getProvider(obj.target)!;\n\n      options = {\n        token: provider.provide,\n        target: provider.useClass,\n        type: HandlerType.CONTROLLER,\n        method: obj.methodClassName\n      };\n    } else {\n      const provider = injector.getProvider(obj);\n\n      if (provider) {\n        options = {\n          token: provider.provide,\n          target: provider.useClass,\n          type: HandlerType.MIDDLEWARE,\n          method: \"use\"\n        };\n      } else {\n        options = {\n          target: obj,\n          type: HandlerType.FUNCTION\n        };\n      }\n    }\n\n    return new HandlerMetadata(options);\n  }\n\n  static handle(process: any, {request, response, next, hasNextFunction}: any) {\n    const done = (error: any, result?: any) => {\n      if (error) {\n        return next(error);\n      }\n\n      if (!hasNextFunction) {\n        if (!next.isCalled && result !== undefined) {\n          request.ctx.data = result;\n        }\n        next();\n      }\n    };\n\n    if (process) {\n      if (process === response) {\n        return;\n      }\n\n      if (isObservable(process)) {\n        // TODO basic support\n        process = process.toPromise();\n      }\n\n      if (isStream(process)) {\n        return done(null, process);\n      }\n\n      if (isFunction(process)) {\n        // when process return a middleware\n        return process(request, response, next);\n      }\n\n      if (isPromise(process)) {\n        return process\n          .then((result: any) =>\n            this.handle(result, {\n              request,\n              response,\n              next,\n              hasNextFunction\n            })\n          )\n          .catch((error: any) => done(error));\n      }\n    }\n\n    if (!hasNextFunction) {\n      // no next function and empty response\n      done(null, process);\n    }\n  }\n\n  /**\n   *\n   * @returns {any}\n   */\n  public build(injector: InjectorService) {\n    const {services, hasErrorParam} = this.handlerMetadata;\n    this.injector = injector;\n    this.debug = injector.settings.debug;\n    this.filters = services.map((param: ParamMetadata) => new FilterBuilder(injector).build(param));\n\n    if (hasErrorParam) {\n      return (err: any, request: any, response: any, next: any) => this.invoke(request, response, next, err);\n    } else {\n      return (request: any, response: any, next: any) => this.invoke(request, response, next);\n    }\n  }\n\n  /**\n   *\n   */\n  private getHandler(locals: Map<string | Function, any>): Function {\n    const {token, method} = this.handlerMetadata;\n\n    // Considering the injector.invoke return always a promise\n    const instance: any = /* await */ this.injector.invoke(token, locals);\n\n    return instance[method!].bind(instance);\n\n    // const {token, method} = this.handlerMetadata;\n    // const provider = this.injector.getProvider(token);\n    //\n    // /* istanbul ignore next */\n    // if (!provider) {\n    //   throw new Error(`${nameOf(token)} component not found in the injector`);\n    // }\n    //\n    // let instance: any;\n    //\n    // if (provider.scope !== ProviderScope.SINGLETON) {\n    //   instance = this.injector.invoke<any>(provider.useClass, locals, undefined, true);\n    //   locals.set(token, instance);\n    // } else {\n    //   instance = this.injector.get<any>(token);\n    // }\n    //\n    // return instance[method!].bind(instance);\n  }\n\n  /**\n   *\n   * @returns {Promise<any>}\n   * @param request\n   * @param response\n   * @param next\n   * @param err\n   */\n  private async invoke(request: Express.Request, response: Express.Response, next: any, err?: any): Promise<any> {\n    const {hasNextFunction} = this.handlerMetadata;\n    const {\n      ctx: {container}\n    } = request;\n\n    next = this.buildNext(request, response, next);\n\n    try {\n      this.log(request, {event: \"invoke.start\"});\n      const args = this.runFilters(request, response, next, err);\n      const process = this.getHandler(container)(...args);\n\n      HandlerBuilder.handle(process, {request, response, next, hasNextFunction});\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  /**\n   *\n   * @param {Express.Request} request\n   * @param o\n   * @returns {string}\n   */\n  private log(request: Express.Request, o: any = {}) {\n    if (request.log && this.debug) {\n      const {target, injectable, method} = this.handlerMetadata;\n\n      request.log.debug(\n        {\n          type: this.handlerMetadata.type,\n          target: (target ? nameOf(target) : target.name) || \"anonymous\",\n          methodName: method,\n          injectable,\n          data: request.ctx.data,\n          ...o\n        },\n        false\n      );\n    }\n  }\n\n  /**\n   *\n   * @param {Express.Request} request\n   * @param {Express.Response} response\n   * @param {Express.NextFunction} next\n   * @returns {any}\n   */\n  private buildNext(request: Express.Request, response: Express.Response, next: any): any {\n    next.isCalled = false;\n    const dateTime = Date.now();\n\n    return (error?: any) => {\n      next.isCalled = true;\n      if (response.headersSent) {\n        return;\n      }\n\n      /* istanbul ignore else */\n      this.log(request, {event: \"invoke.end\", error, execTime: Date.now() - dateTime});\n\n      return next(error);\n    };\n  }\n\n  /**\n   *\n   * @param request\n   * @param response\n   * @param next\n   * @param err\n   */\n  private runFilters(request: Express.Request, response: Express.Response, next: Express.NextFunction, err: any) {\n    return this.filters.map((filter: IFilterPreHandler) => {\n      return filter({\n        request,\n        response,\n        next,\n        err\n      });\n    });\n  }\n}\n"],"sourceRoot":"../../../src"}