"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const rxjs_1 = require("rxjs");
const filters_1 = require("../../filters");
const HandlerType_1 = require("../interfaces/HandlerType");
const EndpointMetadata_1 = require("./EndpointMetadata");
const HandlerMetadata_1 = require("./HandlerMetadata");
/**
 * @stable
 */
class HandlerBuilder {
    constructor(handlerMetadata) {
        this.handlerMetadata = handlerMetadata;
    }
    /**
     *
     * @param obj
     * @returns {HandlerBuilder}
     */
    static from(obj) {
        return {
            build(injector) {
                const handlerMetadata = HandlerBuilder.resolve(obj, injector);
                if (handlerMetadata.type === HandlerType_1.HandlerType.FUNCTION) {
                    // injector.logger.debug("Return handler as function", handlerMetadata.handler.name);
                    return handlerMetadata.handler;
                }
                // injector.logger.trace("Build handler", `${nameOf(handlerMetadata.target)}.${handlerMetadata.method}()`);
                return new HandlerBuilder(handlerMetadata).build(injector);
            }
        };
    }
    static resolve(obj, injector) {
        let options;
        if (obj instanceof EndpointMetadata_1.EndpointMetadata) {
            const provider = injector.getProvider(obj.target);
            options = {
                token: provider.provide,
                target: provider.useClass,
                type: HandlerType_1.HandlerType.CONTROLLER,
                method: obj.methodClassName
            };
        }
        else {
            const provider = injector.getProvider(obj);
            if (provider) {
                options = {
                    token: provider.provide,
                    target: provider.useClass,
                    type: HandlerType_1.HandlerType.MIDDLEWARE,
                    method: "use"
                };
            }
            else {
                options = {
                    target: obj,
                    type: HandlerType_1.HandlerType.FUNCTION
                };
            }
        }
        return new HandlerMetadata_1.HandlerMetadata(options);
    }
    static handle(process, { request, response, next, hasNextFunction }) {
        const done = (error, result) => {
            if (error) {
                return next(error);
            }
            if (!hasNextFunction) {
                if (!next.isCalled && result !== undefined) {
                    request.ctx.data = result;
                }
                next();
            }
        };
        if (process) {
            if (process === response) {
                return;
            }
            if (rxjs_1.isObservable(process)) {
                // TODO basic support
                process = process.toPromise();
            }
            if (core_1.isStream(process)) {
                return done(null, process);
            }
            if (core_1.isFunction(process)) {
                // when process return a middleware
                return process(request, response, next);
            }
            if (core_1.isPromise(process)) {
                return process
                    .then((result) => this.handle(result, {
                    request,
                    response,
                    next,
                    hasNextFunction
                }))
                    .catch((error) => done(error));
            }
        }
        if (!hasNextFunction) {
            // no next function and empty response
            done(null, process);
        }
    }
    /**
     *
     * @returns {any}
     */
    build(injector) {
        const { services, hasErrorParam } = this.handlerMetadata;
        this.injector = injector;
        this.debug = injector.settings.debug;
        this.filters = services.map((param) => new filters_1.FilterBuilder(injector).build(param));
        if (hasErrorParam) {
            return (err, request, response, next) => this.invoke(request, response, next, err);
        }
        else {
            return (request, response, next) => this.invoke(request, response, next);
        }
    }
    /**
     *
     */
    getHandler(locals) {
        const { token, method } = this.handlerMetadata;
        // Considering the injector.invoke return always a promise
        const instance = this.injector.invoke(token, locals);
        return instance[method].bind(instance);
        // const {token, method} = this.handlerMetadata;
        // const provider = this.injector.getProvider(token);
        //
        // /* istanbul ignore next */
        // if (!provider) {
        //   throw new Error(`${nameOf(token)} component not found in the injector`);
        // }
        //
        // let instance: any;
        //
        // if (provider.scope !== ProviderScope.SINGLETON) {
        //   instance = this.injector.invoke<any>(provider.useClass, locals, undefined, true);
        //   locals.set(token, instance);
        // } else {
        //   instance = this.injector.get<any>(token);
        // }
        //
        // return instance[method!].bind(instance);
    }
    /**
     *
     * @returns {Promise<any>}
     * @param request
     * @param response
     * @param next
     * @param err
     */
    invoke(request, response, next, err) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { hasNextFunction } = this.handlerMetadata;
            const { ctx: { container } } = request;
            next = this.buildNext(request, response, next);
            try {
                this.log(request, { event: "invoke.start" });
                const args = this.runFilters(request, response, next, err);
                const process = this.getHandler(container)(...args);
                HandlerBuilder.handle(process, { request, response, next, hasNextFunction });
            }
            catch (error) {
                next(error);
            }
        });
    }
    /**
     *
     * @param {Express.Request} request
     * @param o
     * @returns {string}
     */
    log(request, o = {}) {
        if (request.log && this.debug) {
            const { target, injectable, method } = this.handlerMetadata;
            request.log.debug(Object.assign({ type: this.handlerMetadata.type, target: (target ? core_1.nameOf(target) : target.name) || "anonymous", methodName: method, injectable, data: request.ctx.data }, o), false);
        }
    }
    /**
     *
     * @param {Express.Request} request
     * @param {Express.Response} response
     * @param {Express.NextFunction} next
     * @returns {any}
     */
    buildNext(request, response, next) {
        next.isCalled = false;
        const dateTime = Date.now();
        return (error) => {
            next.isCalled = true;
            if (response.headersSent) {
                return;
            }
            /* istanbul ignore else */
            this.log(request, { event: "invoke.end", error, execTime: Date.now() - dateTime });
            return next(error);
        };
    }
    /**
     *
     * @param request
     * @param response
     * @param next
     * @param err
     */
    runFilters(request, response, next, err) {
        return this.filters.map((filter) => {
            return filter({
                request,
                response,
                next,
                err
            });
        });
    }
}
exports.HandlerBuilder = HandlerBuilder;

//# sourceMappingURL=HandlerBuilder.js.map
