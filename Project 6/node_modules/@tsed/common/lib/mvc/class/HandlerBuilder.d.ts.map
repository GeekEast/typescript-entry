{"version":3,"sources":["mvc/class/HandlerBuilder.ts"],"names":[],"mappings":"AACA,OAAO,EAAC,eAAe,EAAC,MAAM,UAAU,CAAC;AAKzC,OAAO,EAAC,gBAAgB,EAAC,MAAM,oBAAoB,CAAC;AACpD,OAAO,EAAC,eAAe,EAAkB,MAAM,mBAAmB,CAAC;AAEnE;;GAEG;AACH,qBAAa,cAAc;IAKb,OAAO,CAAC,eAAe;IAJnC,OAAO,CAAC,OAAO,CAAQ;IACvB,OAAO,CAAC,KAAK,CAAU;IACvB,OAAO,CAAC,QAAQ,CAAkB;gBAEd,eAAe,EAAE,eAAe;IAEpD;;;;OAIG;IACH,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,GAAG,gBAAgB;;;IAgBvC,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE,GAAG,GAAG,gBAAgB,EAAE,QAAQ,EAAE,eAAe;IAiCrE,MAAM,CAAC,MAAM,CAAC,OAAO,EAAE,GAAG,EAAE,EAAC,OAAO,EAAE,QAAQ,EAAE,IAAI,EAAE,eAAe,EAAC,EAAE,GAAG;IAqD3E;;;OAGG;IACI,KAAK,CAAC,QAAQ,EAAE,eAAe;IAatC;;OAEG;IACH,OAAO,CAAC,UAAU;IA4BlB;;;;;;;OAOG;YACW,MAAM;IAmBpB;;;;;OAKG;IACH,OAAO,CAAC,GAAG;IAkBX;;;;;;OAMG;IACH,OAAO,CAAC,SAAS;IAiBjB;;;;;;OAMG;IACH,OAAO,CAAC,UAAU;CAUnB","file":"HandlerBuilder.d.ts","sourcesContent":["import {isFunction, isPromise, isStream, nameOf} from \"@tsed/core\";\nimport {InjectorService} from \"@tsed/di\";\nimport * as Express from \"express\";\nimport {isObservable} from \"rxjs\";\nimport {FilterBuilder, IFilterPreHandler, ParamMetadata} from \"../../filters\";\nimport {HandlerType} from \"../interfaces/HandlerType\";\nimport {EndpointMetadata} from \"./EndpointMetadata\";\nimport {HandlerMetadata, IHandlerOptions} from \"./HandlerMetadata\";\n\n/**\n * @stable\n */\nexport class HandlerBuilder {\n  private filters: any[];\n  private debug: boolean;\n  private injector: InjectorService;\n\n  constructor(private handlerMetadata: HandlerMetadata) {}\n\n  /**\n   *\n   * @param obj\n   * @returns {HandlerBuilder}\n   */\n  static from(obj: any | EndpointMetadata) {\n    return {\n      build(injector: InjectorService) {\n        const handlerMetadata = HandlerBuilder.resolve(obj, injector);\n\n        if (handlerMetadata.type === HandlerType.FUNCTION) {\n          // injector.logger.debug(\"Return handler as function\", handlerMetadata.handler.name);\n          return handlerMetadata.handler;\n        }\n\n        // injector.logger.trace(\"Build handler\", `${nameOf(handlerMetadata.target)}.${handlerMetadata.method}()`);\n        return new HandlerBuilder(handlerMetadata).build(injector);\n      }\n    };\n  }\n\n  static resolve(obj: any | EndpointMetadata, injector: InjectorService) {\n    let options: IHandlerOptions;\n\n    if (obj instanceof EndpointMetadata) {\n      const provider = injector.getProvider(obj.target)!;\n\n      options = {\n        token: provider.provide,\n        target: provider.useClass,\n        type: HandlerType.CONTROLLER,\n        method: obj.methodClassName\n      };\n    } else {\n      const provider = injector.getProvider(obj);\n\n      if (provider) {\n        options = {\n          token: provider.provide,\n          target: provider.useClass,\n          type: HandlerType.MIDDLEWARE,\n          method: \"use\"\n        };\n      } else {\n        options = {\n          target: obj,\n          type: HandlerType.FUNCTION\n        };\n      }\n    }\n\n    return new HandlerMetadata(options);\n  }\n\n  static handle(process: any, {request, response, next, hasNextFunction}: any) {\n    const done = (error: any, result?: any) => {\n      if (error) {\n        return next(error);\n      }\n\n      if (!hasNextFunction) {\n        if (!next.isCalled && result !== undefined) {\n          request.ctx.data = result;\n        }\n        next();\n      }\n    };\n\n    if (process) {\n      if (process === response) {\n        return;\n      }\n\n      if (isObservable(process)) {\n        // TODO basic support\n        process = process.toPromise();\n      }\n\n      if (isStream(process)) {\n        return done(null, process);\n      }\n\n      if (isFunction(process)) {\n        // when process return a middleware\n        return process(request, response, next);\n      }\n\n      if (isPromise(process)) {\n        return process\n          .then((result: any) =>\n            this.handle(result, {\n              request,\n              response,\n              next,\n              hasNextFunction\n            })\n          )\n          .catch((error: any) => done(error));\n      }\n    }\n\n    if (!hasNextFunction) {\n      // no next function and empty response\n      done(null, process);\n    }\n  }\n\n  /**\n   *\n   * @returns {any}\n   */\n  public build(injector: InjectorService) {\n    const {services, hasErrorParam} = this.handlerMetadata;\n    this.injector = injector;\n    this.debug = injector.settings.debug;\n    this.filters = services.map((param: ParamMetadata) => new FilterBuilder(injector).build(param));\n\n    if (hasErrorParam) {\n      return (err: any, request: any, response: any, next: any) => this.invoke(request, response, next, err);\n    } else {\n      return (request: any, response: any, next: any) => this.invoke(request, response, next);\n    }\n  }\n\n  /**\n   *\n   */\n  private getHandler(locals: Map<string | Function, any>): Function {\n    const {token, method} = this.handlerMetadata;\n\n    // Considering the injector.invoke return always a promise\n    const instance: any = /* await */ this.injector.invoke(token, locals);\n\n    return instance[method!].bind(instance);\n\n    // const {token, method} = this.handlerMetadata;\n    // const provider = this.injector.getProvider(token);\n    //\n    // /* istanbul ignore next */\n    // if (!provider) {\n    //   throw new Error(`${nameOf(token)} component not found in the injector`);\n    // }\n    //\n    // let instance: any;\n    //\n    // if (provider.scope !== ProviderScope.SINGLETON) {\n    //   instance = this.injector.invoke<any>(provider.useClass, locals, undefined, true);\n    //   locals.set(token, instance);\n    // } else {\n    //   instance = this.injector.get<any>(token);\n    // }\n    //\n    // return instance[method!].bind(instance);\n  }\n\n  /**\n   *\n   * @returns {Promise<any>}\n   * @param request\n   * @param response\n   * @param next\n   * @param err\n   */\n  private async invoke(request: Express.Request, response: Express.Response, next: any, err?: any): Promise<any> {\n    const {hasNextFunction} = this.handlerMetadata;\n    const {\n      ctx: {container}\n    } = request;\n\n    next = this.buildNext(request, response, next);\n\n    try {\n      this.log(request, {event: \"invoke.start\"});\n      const args = this.runFilters(request, response, next, err);\n      const process = this.getHandler(container)(...args);\n\n      HandlerBuilder.handle(process, {request, response, next, hasNextFunction});\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  /**\n   *\n   * @param {Express.Request} request\n   * @param o\n   * @returns {string}\n   */\n  private log(request: Express.Request, o: any = {}) {\n    if (request.log && this.debug) {\n      const {target, injectable, method} = this.handlerMetadata;\n\n      request.log.debug(\n        {\n          type: this.handlerMetadata.type,\n          target: (target ? nameOf(target) : target.name) || \"anonymous\",\n          methodName: method,\n          injectable,\n          data: request.ctx.data,\n          ...o\n        },\n        false\n      );\n    }\n  }\n\n  /**\n   *\n   * @param {Express.Request} request\n   * @param {Express.Response} response\n   * @param {Express.NextFunction} next\n   * @returns {any}\n   */\n  private buildNext(request: Express.Request, response: Express.Response, next: any): any {\n    next.isCalled = false;\n    const dateTime = Date.now();\n\n    return (error?: any) => {\n      next.isCalled = true;\n      if (response.headersSent) {\n        return;\n      }\n\n      /* istanbul ignore else */\n      this.log(request, {event: \"invoke.end\", error, execTime: Date.now() - dateTime});\n\n      return next(error);\n    };\n  }\n\n  /**\n   *\n   * @param request\n   * @param response\n   * @param next\n   * @param err\n   */\n  private runFilters(request: Express.Request, response: Express.Response, next: Express.NextFunction, err: any) {\n    return this.filters.map((filter: IFilterPreHandler) => {\n      return filter({\n        request,\n        response,\n        next,\n        err\n      });\n    });\n  }\n}\n"],"sourceRoot":"../../../src"}