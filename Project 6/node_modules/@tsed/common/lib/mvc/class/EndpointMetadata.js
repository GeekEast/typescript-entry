"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const ParamRegistry_1 = require("../../filters/registries/ParamRegistry");
const constants_1 = require("../constants");
/**
 * EndpointMetadata contains metadata about a controller and his method.
 * Each annotation (@Get, @Body...) attached to a method are stored in a endpoint.
 * EndpointMetadata convert this metadata to an array which contain arguments to call an Express method.
 *
 * Example :
 *
 *    @Controller("/my-path")
 *    provide MyClass {
 *
 *        @Get("/")
 *        @Authenticated()
 *        public myMethod(){}
 *    }
 *
 */
class EndpointMetadata extends core_1.Storable {
    constructor(_provide, _methodClassName) {
        super(_provide, _methodClassName, Object.getOwnPropertyDescriptor(_provide, _methodClassName));
        this._methodClassName = _methodClassName;
        // LIFECYCLE
        this.beforeMiddlewares = [];
        this.middlewares = [];
        this.afterMiddlewares = [];
        /**
         * Route strategy.
         */
        this.pathsMethods = [];
        this._type = core_1.Metadata.getReturnType(this._target, this.methodClassName);
    }
    /**
     *
     * @deprecated pathsMethods
     * @returns {string}
     */
    get httpMethod() {
        return this.pathsMethods[0] && this.pathsMethods[0].method;
    }
    /**
     *
     * @deprecated
     * @param value
     */
    set httpMethod(value) {
        if (!this.pathsMethods[0]) {
            this.pathsMethods[0] = {};
        }
        this.pathsMethods[0].method = value;
    }
    /**
     *
     * @deprecated use pathsMethods instead of.
     * @returns {PathParamsType}
     */
    get path() {
        return this.pathsMethods[0] && this.pathsMethods[0].path;
    }
    /**
     *
     * @deprecated
     * @param value
     */
    set path(value) {
        if (!this.pathsMethods[0]) {
            this.pathsMethods[0] = {};
        }
        this.pathsMethods[0].path = value;
    }
    get type() {
        return core_1.isPromise(this._type) || core_1.isArrayOrArrayClass(this._type) || this._type === Object ? undefined : this._type;
    }
    set type(type) {
        this._type = type;
    }
    /**
     *
     */
    get methodClassName() {
        return String(this._methodClassName);
    }
    /**
     *
     * @returns {Store}
     */
    get store() {
        return this.inheritedEndpoint ? this.inheritedEndpoint.store : this._store;
    }
    get statusCode() {
        return this.store.get("statusCode") || 200;
    }
    get params() {
        return ParamRegistry_1.ParamRegistry.getParams(this.target, this.methodClassName);
    }
    /**
     * Find the a value at the controller level. Let this value be extended or overridden by the endpoint itself.
     *
     * @param key
     * @returns {any}
     */
    get(key) {
        const ctrlValue = core_1.Store.from(this.target).get(key);
        let meta = core_1.deepExtends(undefined, ctrlValue);
        const endpointValue = this.store.get(key);
        if (endpointValue !== undefined) {
            meta = core_1.deepExtends(meta, endpointValue);
        }
        return meta;
    }
    /**
     * Change the type and the collection type from the status code.
     * @param {string | number} code
     */
    statusResponse(code) {
        const get = (code) => (this.get("responses") || {})[code] || {};
        let { description, headers, examples } = get(code);
        if (code) {
            const { type, collectionType } = get(code);
            this.type = type;
            this.collectionType = collectionType;
        }
        const expectedStatus = this.statusCode;
        if (+code === +expectedStatus) {
            const response = this.store.get("response");
            if (response) {
                headers = response.headers || headers;
                examples = response.examples || examples;
                description = response.description || description;
                this.type = response.type || this.type;
                this.collectionType = response.collectionType || this.collectionType;
            }
        }
        if (headers) {
            headers = core_1.deepExtends({}, headers);
            Object.keys(headers).forEach(key => {
                delete headers[key].value;
            });
        }
        return {
            headers,
            examples,
            description
        };
    }
    /**
     *
     * @param args
     * @returns {EndpointMetadata}
     */
    before(args) {
        this.beforeMiddlewares = this.beforeMiddlewares.concat(args);
        return this;
    }
    /**
     *
     * @param args
     * @returns {EndpointMetadata}
     */
    after(args) {
        this.afterMiddlewares = this.afterMiddlewares.concat(args);
        return this;
    }
    /**
     * Store all arguments collected via Annotation.
     * @param args
     */
    merge(args) {
        const expressMethods = {};
        const filteredArg = args.filter((arg) => {
            if (typeof arg === "string" && constants_1.EXPRESS_METHODS.indexOf(arg) > -1) {
                expressMethods.method = arg;
                return false;
            }
            if (typeof arg === "string" || arg instanceof RegExp) {
                expressMethods.path = arg;
                return false;
            }
            return !!arg;
        });
        if (expressMethods.method || expressMethods.path) {
            this.pathsMethods.push(expressMethods);
        }
        this.middlewares = this.middlewares.concat(filteredArg);
        return this;
    }
    /**
     *
     * @param {Type<any>} target
     */
    inherit(target) {
        const metadata = new EndpointMetadata(target, this.methodClassName);
        metadata.inheritedEndpoint = this;
        metadata.middlewares = this.middlewares;
        metadata.afterMiddlewares = this.afterMiddlewares;
        metadata.beforeMiddlewares = this.beforeMiddlewares;
        metadata.pathsMethods = metadata.pathsMethods;
        metadata.httpMethod = this.httpMethod;
        metadata.path = this.path;
        metadata.type = this._type;
        return metadata;
    }
}
tslib_1.__decorate([
    core_1.NotEnumerable(),
    tslib_1.__metadata("design:type", EndpointMetadata)
], EndpointMetadata.prototype, "inheritedEndpoint", void 0);
exports.EndpointMetadata = EndpointMetadata;

//# sourceMappingURL=EndpointMetadata.js.map
