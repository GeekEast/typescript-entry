"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class RequestLogger {
    constructor(logger, { id, startDate, url, ignoreUrlPatterns, minimalRequestPicker, completeRequestPicker }) {
        this.logger = logger;
        this.stack = [];
        this.id = id;
        this.url = url;
        this.startDate = startDate;
        this.ignoreUrlPatterns = ignoreUrlPatterns.map((pattern) => typeof pattern === "string" ? new RegExp(pattern, "gi") : pattern);
        this.minimalRequestPicker = minimalRequestPicker;
        this.completeRequestPicker = completeRequestPicker;
    }
    info(obj) {
        this.run(() => {
            const data = this.minimalRequestPicker(this.getData(obj));
            this.stack.push({ level: "info", data });
        });
    }
    debug(obj, withRequest = true) {
        this.run(() => {
            obj = this.getData(obj);
            const data = withRequest ? this.completeRequestPicker(obj) : obj;
            this.stack.push({ level: "debug", data });
        });
    }
    warn(obj) {
        this.run(() => {
            const data = this.completeRequestPicker(this.getData(obj));
            this.stack.push({ level: "warn", data });
        });
    }
    error(obj) {
        this.run(() => {
            const data = this.completeRequestPicker(this.getData(obj));
            this.stack.push({ level: "error", data });
        });
    }
    trace(obj) {
        this.run(() => {
            const data = this.completeRequestPicker(this.getData(obj));
            this.stack.push({ level: "trace", data });
        });
    }
    flush() {
        if (this.stack) {
            this.stack.forEach(({ level, data }) => {
                this.logger[level](data);
            });
        }
    }
    /**
     * Return the duration between the time when LogIncomingRequest has handle the request and now.
     * @returns {number}
     */
    getDuration() {
        return new Date().getTime() - this.startDate.getTime();
    }
    getData(obj) {
        if (typeof obj === "string") {
            obj = { message: obj };
        }
        return Object.assign({ reqId: this.id, time: new Date(), duration: this.getDuration() }, obj);
    }
    run(cb) {
        const match = this.ignoreUrlPatterns.find(reg => !!this.url.match(reg));
        return !match && cb();
    }
}
exports.RequestLogger = RequestLogger;

//# sourceMappingURL=RequestLogger.js.map
