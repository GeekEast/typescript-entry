"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const di_1 = require("@tsed/di");
const ts_log_debug_1 = require("ts-log-debug");
const colorizeUtils_1 = require("ts-log-debug/lib/layouts/utils/colorizeUtils");
/**
 * `RouteService` is used to provide all routes collected by annotation `@Controller`.
 */
let RouteService = class RouteService {
    constructor(injector) {
        this.injector = injector;
        this._routes = [];
    }
    /**
     *
     * @returns {{route: string; provider: any}[]}
     */
    get routes() {
        return this._routes || [];
    }
    /**
     *
     */
    $afterRoutesInit() {
        if (!this.disableRoutesSummary) {
            this.injector.logger.info("Routes mounted :");
            this.printRoutes();
        }
    }
    /**
     *
     * @returns {number}
     * @param route
     */
    addRoute(route) {
        return this._routes.push(route);
    }
    /**
     * Get all routes built by TsExpressDecorators and mounted on Express application.
     * @returns {IControllerRoute[]}
     */
    getRoutes() {
        const routes = [];
        this.routes.forEach((config) => {
            this.buildRoutes(routes, config.provider, config.route);
        });
        return routes;
    }
    /**
     * Print all route mounted in express via Annotation.
     */
    printRoutes() {
        const mapColor = {
            GET: "green",
            POST: "yellow",
            PUT: "blue",
            DELETE: "red",
            PATCH: "magenta",
            ALL: "cyan"
        };
        const routes = this.getRoutes().map(route => {
            const method = route.method.toUpperCase();
            route.method = {
                length: method.length,
                toString: () => {
                    return colorizeUtils_1.colorize(method, mapColor[method]);
                }
            };
            return route;
        });
        const str = ts_log_debug_1.$log.drawTable(routes, {
            padding: 1,
            header: {
                method: "Method",
                url: "Endpoint",
                name: "Class method"
            }
        });
        this.injector.logger.info("\n" + str.trim());
    }
    /**
     * Return all Routes stored in ControllerProvider manager.
     * @returns {IControllerRoute[]}
     */
    getAll() {
        return this.getRoutes();
    }
    /**
     *
     * @param routes
     * @param ctrl
     * @param endpointUrl
     */
    buildRoutes(routes, ctrl, endpointUrl) {
        ctrl.children
            .map(ctrl => this.injector.getProvider(ctrl))
            .forEach((provider) => this.buildRoutes(routes, provider, `${endpointUrl}${provider.path}`));
        ctrl.endpoints.forEach((endpoint) => {
            const { pathsMethods, params, targetName, methodClassName } = endpoint;
            pathsMethods.forEach(({ path, method }) => {
                if (!!method) {
                    routes.push({
                        method,
                        name: `${targetName}.${String(methodClassName)}()`,
                        url: `${endpointUrl}${path || ""}`.replace(/\/\//gi, "/"),
                        className: targetName,
                        methodClassName,
                        parameters: params
                    });
                }
            });
        });
    }
};
tslib_1.__decorate([
    di_1.Constant("logger.disableRoutesSummary", false),
    tslib_1.__metadata("design:type", Boolean)
], RouteService.prototype, "disableRoutesSummary", void 0);
RouteService = tslib_1.__decorate([
    di_1.Service(),
    tslib_1.__metadata("design:paramtypes", [di_1.InjectorService])
], RouteService);
exports.RouteService = RouteService;

//# sourceMappingURL=RouteService.js.map
