"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
var _a;
const core_1 = require("@tsed/core");
const di_1 = require("@tsed/di");
const Express = require("express");
const ServerSettingsService_1 = require("../../config/services/ServerSettingsService");
const expressApplication_1 = require("../../server/decorators/expressApplication"); // TODO should be located on server package
const ControllerBuilder_1 = require("../class/ControllerBuilder");
const ControllerProvider_1 = require("../class/ControllerProvider");
const ControllerRegistry_1 = require("../registries/ControllerRegistry");
const RouteService_1 = require("./RouteService");
/**
 * @private
 */
let ControllerService = class ControllerService extends core_1.ProxyMap {
    /**
     *
     * @param expressApplication
     * @param injectorService
     * @param settings
     * @param routeService
     */
    constructor(injectorService, expressApplication, settings, routeService) {
        super(injectorService, { filter: { type: di_1.ProviderType.CONTROLLER } });
        this.injectorService = injectorService;
        this.expressApplication = expressApplication;
        this.settings = settings;
        this.routeService = routeService;
        this.buildRouters();
    }
    get routes() {
        return this.routeService.routes || [];
    }
    /**
     *
     * @param target
     * @returns {ControllerProvider}
     * @deprecated
     */
    static get(target) {
        return ControllerRegistry_1.ControllerRegistry.get(target);
    }
    /**
     *
     * @param target
     * @deprecated
     */
    static has(target) {
        return ControllerRegistry_1.ControllerRegistry.has(target);
    }
    /**
     *
     * @param target
     * @param provider
     * @deprecated
     */
    static set(target, provider) {
        ControllerRegistry_1.ControllerRegistry.set(target, provider);
        return this;
    }
    /**
     *
     * @param components
     */
    $onRoutesInit(components) {
        this.injectorService.logger.info("Map controllers");
        this.mapComponents(components);
    }
    /**
     * Invoke a controller from his Class.
     * @param target
     * @param locals
     * @param designParamTypes
     * @returns {T}
     * @deprecated
     */
    invoke(target, locals = new Map(), designParamTypes) {
        return this.injectorService.invoke(target.provide || target, locals);
    }
    /**
     * Build routers and con
     */
    buildRouters() {
        this.forEach((provider) => {
            if (!provider.hasParent()) {
                new ControllerBuilder_1.ControllerBuilder(provider).build(this.injectorService);
            }
        });
    }
    /**
     *
     * @param components
     */
    mapComponents(components) {
        components.forEach(component => {
            Object.keys(component.classes)
                .map(clazzName => component.classes[clazzName])
                .filter(clazz => component.endpoint && this.has(clazz))
                .map(clazz => this.get(clazz))
                .forEach((provider) => {
                if (!provider.hasParent()) {
                    this.mountRouter(component.endpoint, provider);
                }
            });
        });
    }
    /**
     *
     * @param {string} endpoint
     * @param {ControllerProvider} provider
     */
    mountRouter(endpoint, provider) {
        const route = provider.getEndpointUrl(endpoint);
        this.routeService.addRoute({ provider, route });
        this.expressApplication.use(route, provider.router);
    }
};
tslib_1.__decorate([
    core_1.Deprecated("ControllerService.invoke(). Removed feature. Use injectorService.invoke instead of."),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Map, Array]),
    tslib_1.__metadata("design:returntype", typeof (_a = typeof T !== "undefined" && T) === "function" ? _a : Object)
], ControllerService.prototype, "invoke", null);
tslib_1.__decorate([
    core_1.Deprecated("static ControllerService.get(). Removed feature."),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [core_1.Type]),
    tslib_1.__metadata("design:returntype", Object)
], ControllerService, "get", null);
tslib_1.__decorate([
    core_1.Deprecated("static ControllerService.has(). Removed feature."),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [core_1.Type]),
    tslib_1.__metadata("design:returntype", void 0)
], ControllerService, "has", null);
tslib_1.__decorate([
    core_1.Deprecated("static ControllerService.set(). Removed feature."),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [core_1.Type, ControllerProvider_1.ControllerProvider]),
    tslib_1.__metadata("design:returntype", void 0)
], ControllerService, "set", null);
ControllerService = tslib_1.__decorate([
    di_1.Injectable({
        scope: di_1.ProviderScope.SINGLETON,
        global: true
    }),
    tslib_1.__param(1, expressApplication_1.ExpressApplication),
    tslib_1.__metadata("design:paramtypes", [di_1.InjectorService, Function, ServerSettingsService_1.ServerSettingsService,
        RouteService_1.RouteService])
], ControllerService);
exports.ControllerService = ControllerService;

//# sourceMappingURL=ControllerService.js.map
