{"version":3,"sources":["converters/services/ConverterService.ts"],"names":[],"mappings":"AACA,OAAO,EAAC,eAAe,EAAU,MAAM,UAAU,CAAC;AAClD,OAAO,EAAC,qBAAqB,EAAC,MAAM,6CAA6C,CAAC;AAClF,OAAO,EAAC,gBAAgB,EAAC,MAAM,yCAAyC,CAAC;AAOzE,OAAO,EAAC,UAAU,EAAE,iBAAiB,EAA6B,MAAM,qBAAqB,CAAC;AAE9F,qBACa,gBAAgB;IAGf,OAAO,CAAC,eAAe;IAFnC,OAAO,CAAC,qBAAqB,CAAQ;gBAEjB,eAAe,EAAE,eAAe,EAAE,cAAc,EAAE,qBAAqB;IAI3F;;;;;OAKG;IACH,MAAM,CAAC,mBAAmB,CACxB,UAAU,EAAE,GAAG,CAAC,MAAM,GAAG,MAAM,EAAE,gBAAgB,CAAC,EAClD,WAAW,EAAE,MAAM,GAAG,MAAM,GAC3B,gBAAgB,GAAG,SAAS;IAe/B;;;;;;;;;OASG;IACH,SAAS,CAAC,GAAG,EAAE,GAAG,EAAE,OAAO,GAAE,iBAAsB,GAAG,GAAG;IA0CzD;;;;;OAKG;IACH,cAAc,CAAC,GAAG,EAAE,GAAG,EAAE,OAAO,GAAE,iBAAsB;IA4BxD;;;;;;;;;;;;;OAaG;IACH,WAAW,CAAC,GAAG,EAAE,GAAG,EAAE,UAAU,EAAE,GAAG,EAAE,QAAQ,CAAC,EAAE,GAAG,EAAE,OAAO,GAAE,iBAAsB,GAAG,GAAG;IA0D5F;;;;OAIG;IACH,YAAY,CAAC,UAAU,EAAE,GAAG,GAAG,UAAU,GAAG,SAAS;IAUrD;;;;;;;OAOG;IACH,OAAO,CAAC,eAAe;IA6BvB;;;;OAIG;IACH,OAAO,CAAC,kBAAkB;IAQ1B;;;;;OAKG;IACH,OAAO,CAAC,0BAA0B;IAMlC;;;;OAIG;IACH,OAAO,CAAC,uBAAuB;CAahC","file":"ConverterService.d.ts","sourcesContent":["import {getClass, isArrayOrArrayClass, isEmpty, isPrimitiveOrPrimitiveClass, Metadata, Store, Type} from \"@tsed/core\";\nimport {InjectorService, Service} from \"@tsed/di\";\nimport {ServerSettingsService} from \"../../config/services/ServerSettingsService\";\nimport {PropertyMetadata} from \"../../jsonschema/class/PropertyMetadata\";\nimport {PropertyRegistry} from \"../../jsonschema/registries/PropertyRegistry\";\nimport {CONVERTER} from \"../constants/index\";\nimport {ConverterDeserializationError} from \"../errors/ConverterDeserializationError\";\nimport {ConverterSerializationError} from \"../errors/ConverterSerializationError\";\nimport {RequiredPropertyError} from \"../errors/RequiredPropertyError\";\nimport {UnknowPropertyError} from \"../errors/UnknowPropertyError\";\nimport {IConverter, IConverterOptions, IDeserializer, ISerializer} from \"../interfaces/index\";\n\n@Service()\nexport class ConverterService {\n  private validationModelStrict = true;\n\n  constructor(private injectorService: InjectorService, serverSettings: ServerSettingsService) {\n    this.validationModelStrict = serverSettings.get<boolean>(\"validationModelStrict\");\n  }\n\n  /**\n   * Return a JsonMetadata for a properties.\n   * @param properties\n   * @param propertyKey\n   * @returns {undefined|V|string|any|T|IDBRequest}\n   */\n  static getPropertyMetadata(\n    properties: Map<string | symbol, PropertyMetadata>,\n    propertyKey: string | symbol\n  ): PropertyMetadata | undefined {\n    if (properties.has(propertyKey)) {\n      return properties.get(propertyKey);\n    }\n\n    let property;\n    properties.forEach(p => {\n      if (p.name === propertyKey || p.propertyKey === propertyKey) {\n        property = p;\n      }\n    });\n\n    return property;\n  }\n\n  /**\n   * Convert instance to plainObject.\n   *\n   * ### Options\n   *\n   * - `checkRequiredValue`: Disable the required check condition.\n   *\n   * @param obj\n   * @param options\n   */\n  serialize(obj: any, options: IConverterOptions = {}): any {\n    try {\n      if (isEmpty(obj)) {\n        return obj;\n      }\n\n      const converter = this.getConverter(obj);\n      const serializer: ISerializer = (o: any, opt?: any) => this.serialize(o, Object.assign({}, options, opt));\n\n      if (converter && converter.serialize) {\n        // deserialize from a custom JsonConverter\n        return converter.serialize(obj, serializer);\n      }\n\n      if (typeof obj.serialize === \"function\") {\n        // deserialize from serialize method\n        return obj.serialize(options, this);\n      }\n\n      // TODO revert change which break current projects\n      // if (options.type && !isPrimitiveOrPrimitiveClass(options.type)) {\n      //  return this.serializeClass(obj, options);\n      // }\n\n      if (typeof obj.toJSON === \"function\" && !obj.toJSON.$ignore) {\n        // deserialize from serialize method\n        return obj.toJSON();\n      }\n\n      // Default converter\n      if (!isPrimitiveOrPrimitiveClass(obj)) {\n        return this.serializeClass(obj, options);\n      }\n    } catch (err) {\n      /* istanbul ignore next */\n      throw err.name === \"BAD_REQUEST\" ? err : new ConverterSerializationError(getClass(obj), err);\n    }\n\n    /* istanbul ignore next */\n    return obj;\n  }\n\n  /**\n   *\n   * @param obj\n   * @param {IConverterOptions} options\n   * @returns {any}\n   */\n  serializeClass(obj: any, options: IConverterOptions = {}) {\n    const {checkRequiredValue = true} = options;\n\n    const plainObject: any = {};\n    const properties = PropertyRegistry.getProperties(options.type || obj);\n    const keys = properties.size ? Array.from(properties.keys()) : Object.keys(obj);\n\n    keys.forEach(propertyKey => {\n      if (typeof obj[propertyKey] !== \"function\") {\n        let propertyMetadata = ConverterService.getPropertyMetadata(properties, propertyKey);\n\n        propertyMetadata = propertyMetadata || ({} as any);\n        plainObject[propertyMetadata!.name || propertyKey] = this.serialize(obj[propertyKey], {\n          checkRequiredValue // ,\n          // TODO revert change\n          // type: propertyMetadata!.type\n        });\n      }\n    });\n\n    // Required validation\n    if (checkRequiredValue) {\n      this.checkRequiredValue(obj, properties);\n    }\n\n    return plainObject;\n  }\n\n  /**\n   * Convert a plainObject to targetType.\n   *\n   * ### Options\n   *\n   * - `ignoreCallback`: callback called for each object which will be deserialized. The callback can return a boolean to avoid the default converter behavior.\n   * - `checkRequiredValue`: Disable the required check condition.\n   *\n   * @param obj Object source that will be deserialized\n   * @param targetType Pattern of the object deserialized\n   * @param baseType\n   * @param options\n   * @returns {any}\n   */\n  deserialize(obj: any, targetType: any, baseType?: any, options: IConverterOptions = {}): any {\n    const {ignoreCallback, checkRequiredValue = true} = options;\n\n    try {\n      if (ignoreCallback && ignoreCallback(obj, targetType, baseType)) {\n        return obj;\n      }\n\n      if (targetType !== Boolean && (isEmpty(obj) || isEmpty(targetType) || targetType === Object)) {\n        return obj;\n      }\n\n      const converter = this.getConverter(targetType);\n      const deserializer: IDeserializer = (o: any, targetType: any, baseType: any) => this.deserialize(o, targetType, baseType, options);\n\n      if (converter) {\n        // deserialize from a custom JsonConverter\n        return converter!.deserialize!(obj, targetType, baseType, deserializer);\n      }\n\n      /* istanbul ignore next */\n      if (isArrayOrArrayClass(obj)) {\n        const converter = this.getConverter(Array);\n\n        return converter!.deserialize!(obj, Array, baseType, deserializer);\n      }\n\n      if ((targetType as any).prototype && typeof (targetType as any).prototype.deserialize === \"function\") {\n        // deserialize from method\n\n        const instance = new targetType();\n        instance.deserialize(obj);\n\n        return instance;\n      }\n\n      // Default converter\n      const instance = new targetType();\n      const properties = PropertyRegistry.getProperties(targetType);\n\n      Object.keys(obj).forEach((propertyName: string) => {\n        const propertyMetadata = ConverterService.getPropertyMetadata(properties, propertyName);\n\n        return this.convertProperty(obj, instance, propertyName, propertyMetadata, options);\n      });\n\n      // Required validation\n      if (checkRequiredValue) {\n        this.checkRequiredValue(instance, properties);\n      }\n\n      return instance;\n    } catch (err) {\n      /* istanbul ignore next */\n      throw err.name === \"BAD_REQUEST\" ? err : new ConverterDeserializationError(targetType, obj, err);\n    }\n  }\n\n  /**\n   *\n   * @param targetType\n   * @returns {any}\n   */\n  getConverter(targetType: any): IConverter | undefined {\n    if (Metadata.has(CONVERTER, targetType)) {\n      const converter = Metadata.get(CONVERTER, targetType);\n\n      if (converter) {\n        return this.injectorService.get(converter);\n      }\n    }\n  }\n\n  /**\n   *\n   * @param obj\n   * @param instance\n   * @param {string} propertyName\n   * @param {PropertyMetadata} propertyMetadata\n   * @param options\n   */\n  private convertProperty(obj: any, instance: any, propertyName: string, propertyMetadata?: PropertyMetadata, options?: any) {\n    this.checkStrictModelValidation(instance, propertyName, propertyMetadata);\n\n    propertyMetadata = propertyMetadata || ({} as any);\n\n    const propertyValue = obj[propertyMetadata!.name] || obj[propertyName];\n    const propertyKey = propertyMetadata!.propertyKey || propertyName;\n\n    try {\n      if (typeof instance[propertyKey] !== \"function\") {\n        instance[propertyKey] = this.deserialize(\n          propertyValue,\n          propertyMetadata!.isCollection ? propertyMetadata!.collectionType : propertyMetadata!.type,\n          propertyMetadata!.type,\n          options\n        );\n      }\n    } catch (err) {\n      /* istanbul ignore next */\n      (() => {\n        const castedError: any = new Error(\"For \" + String(propertyKey) + \" with value \" + propertyValue + \" \\n\" + err.message);\n        castedError.stack = err.stack;\n        castedError.origin = err;\n\n        throw castedError;\n      })();\n    }\n  }\n\n  /**\n   *\n   * @param instance\n   * @param {Map<string | symbol, PropertyMetadata>} properties\n   */\n  private checkRequiredValue(instance: any, properties: Map<string | symbol, PropertyMetadata>) {\n    properties.forEach((propertyMetadata: PropertyMetadata) => {\n      if (propertyMetadata.isRequired(instance[propertyMetadata.propertyKey])) {\n        throw new RequiredPropertyError(getClass(instance), propertyMetadata.propertyKey);\n      }\n    });\n  }\n\n  /**\n   *\n   * @param instance\n   * @param {string} propertyKey\n   * @param {PropertyMetadata | undefined} propertyMetadata\n   */\n  private checkStrictModelValidation(instance: any, propertyKey: string | symbol, propertyMetadata: PropertyMetadata | undefined) {\n    if (this.isStrictModelValidation(getClass(instance)) && propertyMetadata === undefined) {\n      throw new UnknowPropertyError(getClass(instance), propertyKey);\n    }\n  }\n\n  /**\n   *\n   * @param {Type<any>} target\n   * @returns {boolean}\n   */\n  private isStrictModelValidation(target: Type<any>): boolean {\n    if (target !== Object) {\n      const modelStrict = Store.from(target).get(\"modelStrict\");\n\n      if (this.validationModelStrict) {\n        return modelStrict === undefined ? true : modelStrict;\n      } else {\n        return modelStrict === true;\n      }\n    }\n\n    return false;\n  }\n}\n"],"sourceRoot":"../../../src"}