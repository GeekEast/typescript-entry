{"version":3,"sources":["server/components/GlobalErrorHandlerMiddleware.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,OAAO,MAAM,SAAS,CAAC;AAEnC,OAAO,EAAM,GAAG,EAAE,GAAG,EAAC,MAAM,eAAe,CAAC;AAC5C,OAAO,EAAC,gBAAgB,EAAE,cAAc,EAAa,MAAM,WAAW,CAAC;AAEvE;;GAEG;AACH,qBACa,4BAA6B,YAAW,gBAAgB;IAEnE,SAAS,CAAC,UAAU,EAAE,MAAM,CAAC;IAE7B,GAAG,CAAQ,KAAK,EAAE,GAAG,EAAS,OAAO,EAAE,GAAG,EAAS,QAAQ,EAAE,GAAG,GAAG,GAAG;IA0CtE,UAAU,CAAC,QAAQ,EAAE,OAAO,CAAC,QAAQ,EAAE,GAAG,IAAI,EAAE,cAAc,EAAE;CAmBjE","file":"GlobalErrorHandlerMiddleware.d.ts","sourcesContent":["import {Constant} from \"@tsed/di\";\nimport * as Express from \"express\";\nimport {Exception} from \"ts-httpexceptions\";\nimport {Err, Req, Res} from \"../../filters\";\nimport {IMiddlewareError, IResponseError, Middleware} from \"../../mvc\";\n\n/**\n * @middleware\n */\n@Middleware()\nexport class GlobalErrorHandlerMiddleware implements IMiddlewareError {\n  @Constant(\"errors.headerName\", \"errors\")\n  protected headerName: string;\n\n  use(@Err() error: any, @Req() request: Req, @Res() response: Res): any {\n    const toHTML = (message = \"\") => message.replace(/\\n/gi, \"<br />\");\n\n    if (error instanceof Exception || error.status) {\n      request.log.error({\n        error: {\n          message: error.message,\n          stack: error.stack,\n          status: error.status,\n          origin: error.origin\n        }\n      });\n\n      this.setHeaders(response, error, error.origin);\n\n      response.status(error.status).send(toHTML(error.message));\n\n      return;\n    }\n\n    if (typeof error === \"string\") {\n      response.status(404).send(toHTML(error));\n\n      return;\n    }\n\n    request.log.error({\n      error: {\n        status: 500,\n        message: error.message,\n        stack: error.stack,\n        origin: error.origin\n      }\n    });\n\n    this.setHeaders(response, error, error.origin);\n\n    response.status(error.status || 500).send(\"Internal Error\");\n\n    return;\n  }\n\n  setHeaders(response: Express.Response, ...args: IResponseError[]) {\n    let hErrors: any = [];\n\n    args\n      .filter(o => !!o)\n      .forEach(({headers, errors}: IResponseError) => {\n        if (headers) {\n          response.set(headers);\n        }\n\n        if (errors) {\n          hErrors = hErrors.concat(errors);\n        }\n      });\n\n    if (hErrors.length) {\n      response.set(this.headerName, JSON.stringify(hErrors));\n    }\n  }\n}\n"],"sourceRoot":"../../../src"}