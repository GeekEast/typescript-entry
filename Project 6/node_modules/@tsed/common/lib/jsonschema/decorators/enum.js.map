{"version":3,"sources":["jsonschema/decorators/enum.ts"],"names":[],"mappings":";;AACA,4EAAuE;AAEvE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA4FG;AACH,SAAgB,IAAI,CAAC,SAAgC,EAAE,GAAG,UAA6B;IACrF,OAAO,+CAAsB,CAAC,MAAM,CAAC,EAAE;QACrC,IAAI,OAAO,SAAS,KAAK,QAAQ,EAAE;YACjC,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,MAAM,CACxC,CAAC,GAAQ,EAAE,GAAQ,EAAE,EAAE;gBACrB,IAAI,KAAK,CAAC,CAAC,GAAG,CAAC,EAAE;oBACf,MAAM,KAAK,GAAG,SAAS,CAAC,GAAG,CAAC,CAAC;oBAC7B,MAAM,IAAI,GAAG,OAAO,KAAK,CAAC;oBAE1B,IAAI,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;wBACjC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;qBACrB;oBAED,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;iBACxB;gBAED,OAAO,GAAG,CAAC;YACb,CAAC,EACD,EAAC,IAAI,EAAE,EAAE,EAAE,MAAM,EAAE,EAAE,EAAC,CACvB,CAAC;YAEF,MAAM,CAAC,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;YACvE,MAAM,CAAC,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC;SAClC;aAAM;YACL,MAAM,CAAC,MAAM,CAAC,IAAI,GAAG,CAAC,SAAS,CAAC,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;SACrD;IACH,CAAC,CAAC,CAAC;AACL,CAAC;AA3BD,oBA2BC","file":"enum.js","sourcesContent":["import {JSONSchema6Type} from \"json-schema\";\nimport {decoratorSchemaFactory} from \"../utils/decoratorSchemaFactory\";\n\n/**\n * The enum keyword is used to restrict a value to a fixed set of values.\n * It must be an array with at least one element, where each element is unique.\n *\n * Elements in the array might be of any value, including null.\n *\n * ## Example\n * ### With primitive type\n *\n * ```typescript\n * class Model {\n *    @Enum(\"value1\", \"value2\")\n *    property: \"value1\" | \"value2\";\n * }\n * ```\n *\n * Will produce:\n *\n * ```json\n * {\n *   \"type\": \"object\",\n *   \"properties\": {\n *     \"property\": {\n *       \"type\": \"string\",\n *       \"enum\": [\"value1\", \"value2\"]\n *     }\n *   }\n * }\n * ```\n *\n * ### With array type\n *\n * ```typescript\n * class Model {\n *    @Enum(\"value1\", \"value2\")\n *    property: (\"value1\" |Â \"value2\")[];\n * }\n * ```\n *\n * Will produce:\n *\n * ```json\n * {\n *   \"type\": \"object\",\n *   \"properties\": {\n *     \"property\": {\n *       \"type\": \"array\",\n *       \"items\": {\n *          \"type\": \"string\",\n *          \"enum\": [\"value1\", \"value2\"]\n *       }\n *     }\n *   }\n * }\n * ```\n *\n * ### With Typescript Enum\n *\n * ```typescript\n * enum SomeEnum {\n *    ENUM_1 = \"enum1\",\n *    ENUM_2 = \"enum2\"\n * }\n *\n * class Model {\n *    @Enum(SomeEnum)\n *    property: SomeEnum;\n * }\n * ```\n *\n * Will produce:\n *\n * ```json\n * {\n *   \"type\": \"object\",\n *   \"properties\": {\n *     \"property\": {\n *        \"type\": \"string\",\n *        \"enum\": [\"enum1\", \"enum2\"]\n *     }\n *   }\n * }\n * ```\n *\n * @param {string | number | boolean | {}} enumValue\n * @param enumValues\n * @returns {Function}\n * @decorator\n * @ajv\n * @property\n * @jsonschema\n * @auto-map The data will be stored on the right place according to the type and collectionType (primitive or collection).\n */\nexport function Enum(enumValue: JSONSchema6Type | any, ...enumValues: JSONSchema6Type[]) {\n  return decoratorSchemaFactory(schema => {\n    if (typeof enumValue === \"object\") {\n      const info = Object.keys(enumValue).reduce(\n        (acc: any, key: any) => {\n          if (isNaN(+key)) {\n            const value = enumValue[key];\n            const type = typeof value;\n\n            if (acc.type.indexOf(type) === -1) {\n              acc.type.push(type);\n            }\n\n            acc.values.push(value);\n          }\n\n          return acc;\n        },\n        {type: [], values: []}\n      );\n\n      schema.mapper.type = info.type.length === 1 ? info.type[0] : info.type;\n      schema.mapper.enum = info.values;\n    } else {\n      schema.mapper.enum = [enumValue].concat(enumValues);\n    }\n  });\n}\n"],"sourceRoot":"../../../src"}