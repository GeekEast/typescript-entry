{"version":3,"sources":["jsonschema/decorators/jsonProperty.ts"],"names":[],"mappings":";;AAAA,qCAA8D;AAG9D,qEAAgE;AAEhE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAwFG;AACH,SAAgB,YAAY,CAAC,OAAmC;IAC9D,OAAO,UAAU,CAAC,CAAC,gBAAkC,EAAE,EAAE;QACvD,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE;YAC/B,gBAAgB,CAAC,IAAI,GAAG,OAAiB,CAAC;SAC3C;aAAM,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE;YACtC,gBAAgB,CAAC,IAAI,GAAG,OAAO,CAAC,IAAc,CAAC;YAE/C,IAAI,CAAC,cAAO,CAAE,OAA4B,CAAC,GAAG,CAAC,EAAE;gBAC/C,gBAAgB,CAAC,IAAI,GAAI,OAA4B,CAAC,GAAgB,CAAC;aACxE;SACF;IACH,CAAC,CAAC,CAAC;AACL,CAAC;AAZD,oCAYC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAuFG;AACH,SAAgB,QAAQ,CAAC,OAAmC;IAC1D,OAAO,YAAY,CAAC,OAAO,CAAC,CAAC;AAC/B,CAAC;AAFD,4BAEC;AAED;;;;;;GAMG;AACH,SAAgB,UAAU,CAAC,EAAiF;IAC1G,OAAO,mCAAgB,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;AACvC,CAAC;AAFD,gCAEC","file":"jsonProperty.js","sourcesContent":["import {DecoratorParameters, isEmpty, Type} from \"@tsed/core\";\nimport {IPropertyOptions} from \"../../converters/interfaces/IPropertyOptions\";\nimport {PropertyMetadata} from \"../class/PropertyMetadata\";\nimport {PropertyRegistry} from \"../registries/PropertyRegistry\";\n\n/**\n * `@JsonProperty()` let you decorate an attribute that can be serialized or deserialized. By default, no parameters are required to use it.\n * But in some cases, we need to configure explicitly the JSON attribute name mapped to the provide attribute.\n *\n * Here an example of different use cases with `@JsonProperty()`:\n *\n * ```typescript\n * class EventModel {\n *\n *    @JsonProperty()\n *    name: string;\n *\n *    @JsonProperty()\n *    @Format('date-time')\n *    startDate: Date;\n *\n *    @JsonProperty({name: 'end-date'}) // alias nam doesn't work with JsonSchema\n *    @Format('date-time')\n *    endDate: Date;\n *\n *    @PropertyType(Task) // eq. @Property({use: Task})\n *    tasks: TaskModel[];\n * }\n *\n * class TaskModel {\n *     @Property()\n *     subject: string;\n *\n *     @Minimum(0)  // Property or JsonProperty is not required when a JsonSchema decorator is used\n *     @Maximum(100)\n *     rate: number;\n * }\n *\n * > Theses ES6 collections can be used: Map and Set. Map will be serialized as an object and Set as an array.\n * By default Date, Array, Map and Set have a default custom Converter already embed. But you can override theses (see next part).\n *\n * For the Array, you must use the `@PropertyType` decorator.\n * `TypeClass` will be used to deserialize each item in the collection stored on the attribute source.\n *\n * According to the previous example, the JsonSchema generated will be as follow:\n *\n * ```typescript\n * {\n *    \"type\": \"object\",\n *    \"properties\": {\n *       \"name\": {\n *          \"type\": \"string\"\n *       },\n *       \"startDate\": {\n *          \"type\": \"string\",\n *          \"format\": \"date-time\"\n *       },\n *       \"endDate\": {\n *          \"type\": \"string\",\n *          \"format\": \"date-time\"\n *       },\n *       \"tasks\": {\n *          \"type\": \"array\",\n *          \"items\": {\n *             \"$ref\": \"#/definitions/Task\"\n *          }\n *       }\n *    },\n *    \"definitions\": {\n *      \"Task\": {\n *        \"type\": \"object\",\n *        \"properties\": {\n *          \"subject\": {\n *             \"type\": \"string\",\n *          },\n *          \"rate\": {\n *             \"type\": \"number\"\n *             \"minimum\": 0,\n *             \"maximum: 100\n *          }\n *        }\n *      }\n *    }\n * }\n * ```\n *\n * @returns {Function}\n * @decorator\n * @param options\n * @decorator\n * @converters\n * @jsonschema\n * @property\n */\nexport function JsonProperty(options?: IPropertyOptions | string): Function {\n  return PropertyFn((propertyMetadata: PropertyMetadata) => {\n    if (typeof options === \"string\") {\n      propertyMetadata.name = options as string;\n    } else if (typeof options === \"object\") {\n      propertyMetadata.name = options.name as string;\n\n      if (!isEmpty((options as IPropertyOptions).use)) {\n        propertyMetadata.type = (options as IPropertyOptions).use as Type<any>;\n      }\n    }\n  });\n}\n\n/**\n * `@Property()` let you decorate an attribute that can be serialized or deserialized. By default, no parameters are required to use it.\n * But in some cases, we need to configure explicitly the JSON attribute name mapped to the provide attribute.\n *\n * Here an example of different use cases with `@Property()`:\n *\n * ```typescript\n * class EventModel {\n *\n *    @Property()\n *    name: string;\n *\n *    @Property()\n *    @Format('date-time')\n *    startDate: Date;\n *\n *    @Property({name: 'end-date'})\n *    @Format('date-time')\n *    endDate: Date;\n *\n *    @PropertyType(Task) // eq. @Property({use: Task})\n *    tasks: TaskModel[];\n * }\n *\n * class TaskModel {\n *     @Property()\n *     subject: string;\n *\n *     @Minimum(0)  // Property or JsonProperty is not required when a JsonSchema decorator is used\n *     @Maximum(100)\n *     rate: number;\n * }\n *\n * > Theses ES6 collections can be used: Map and Set. Map will be serialized as an object and Set as an array.\n * By default Date, Array, Map and Set have a default custom Converter already embed. But you can override theses (see next part).\n *\n * For the Array, you must use the `@PropertyType` decorator.\n * `TypeClass` will be used to deserialize each item in the collection stored on the attribute source.\n *\n * According to the previous example, the JsonSchema generated will be as follow:\n *\n * ```typescript\n * {\n *    \"type\": \"object\",\n *    \"properties\": {\n *       \"name\": {\n *          \"type\": \"string\"\n *       },\n *       \"startDate\": {\n *          \"type\": \"string\",\n *          \"format\": \"date-time\"\n *       },\n *       \"endDate\": {\n *          \"type\": \"string\",\n *          \"format\": \"date-time\"\n *       },\n *       \"tasks\": {\n *          \"type\": \"array\",\n *          \"items\": {\n *             \"$ref\": \"#/definitions/Task\"\n *          }\n *       }\n *    },\n *    \"definitions\": {\n *      \"Task\": {\n *        \"type\": \"object\",\n *        \"properties\": {\n *          \"subject\": {\n *             \"type\": \"string\",\n *          },\n *          \"rate\": {\n *             \"type\": \"number\"\n *             \"minimum\": 0,\n *             \"maximum: 100\n *          }\n *        }\n *      }\n *    }\n * }\n * ```\n *\n * @returns {Function}\n * @param options\n * @decorator\n * @converters\n * @jsonschema\n * @property\n */\nexport function Property(options?: IPropertyOptions | string) {\n  return JsonProperty(options);\n}\n\n/**\n * Decorator builder. Call your function with `propertyMetadata` and `DecoratorParameters` a input parameters\n * @decorator\n * @converters\n * @jsonschema\n * @property\n */\nexport function PropertyFn(fn: (propertyMetadata: PropertyMetadata, parameters: DecoratorParameters) => void): Function {\n  return PropertyRegistry.decorate(fn);\n}\n"],"sourceRoot":"../../../src"}