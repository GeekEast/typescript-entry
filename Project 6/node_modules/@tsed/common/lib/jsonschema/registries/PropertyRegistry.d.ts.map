{"version":3,"sources":["jsonschema/registries/PropertyRegistry.ts"],"names":[],"mappings":"AAAA,OAAO,EAAc,mBAAmB,EAAY,IAAI,EAAC,MAAM,YAAY,CAAC;AAE5E,OAAO,EAAC,gBAAgB,EAAC,MAAM,2BAA2B,CAAC;AAE3D,qBAAa,gBAAgB;IAC3B;;;;;OAKG;IACH,MAAM,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,WAAW,EAAE,MAAM,GAAG,MAAM,GAAG,gBAAgB;IAU7E;;;;OAIG;IACH,MAAM,CAAC,aAAa,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,MAAM,GAAG,MAAM,EAAE,gBAAgB,CAAC;IAsB/E;;;;OAIG;IACH,MAAM,CAAC,gBAAgB,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,MAAM,GAAG,MAAM,EAAE,gBAAgB,CAAC;IAMlF;;;;;OAKG;IACH,MAAM,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,WAAW,EAAE,MAAM,GAAG,MAAM,EAAE,QAAQ,EAAE,gBAAgB,GAAG,IAAI;IAQ7F;;;;;OAKG;IACH,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,WAAW,EAAE,MAAM,GAAG,MAAM,EAAE,qBAAqB,GAAE,GAAG,EAAO;IAgBlG;;;;OAIG;IACH,MAAM,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC,gBAAgB,EAAE,gBAAgB,EAAE,UAAU,EAAE,mBAAmB,KAAK,IAAI,GAAG,QAAQ;CAS7G","file":"PropertyRegistry.d.ts","sourcesContent":["import {ancestorsOf, DecoratorParameters, Metadata, Type} from \"@tsed/core\";\nimport {PROPERTIES_METADATA} from \"../../converters/constants/index\";\nimport {PropertyMetadata} from \"../class/PropertyMetadata\";\n\nexport class PropertyRegistry {\n  /**\n   *\n   * @param target\n   * @param propertyKey\n   * @returns {PropertyMetadata}\n   */\n  static get(target: Type<any>, propertyKey: string | symbol): PropertyMetadata {\n    const properties = this.getOwnProperties(target);\n\n    if (!properties.has(propertyKey)) {\n      this.set(target, propertyKey, new PropertyMetadata(target, propertyKey));\n    }\n\n    return this.getOwnProperties(target).get(propertyKey)!;\n  }\n\n  /**\n   *\n   * @param target\n   * @returns {Array}\n   */\n  static getProperties(target: Type<any>): Map<string | symbol, PropertyMetadata> {\n    const map = new Map<string | symbol, PropertyMetadata>();\n    const ignored: string[] = [];\n\n    ancestorsOf(target).forEach(klass => {\n      this.getOwnProperties(klass).forEach((v: PropertyMetadata, k: string) => {\n        /* istanbul ignore next */\n        if (ignored.indexOf(k) !== -1) {\n          return;\n        }\n        if (!v.ignoreProperty) {\n          map.set(k, v);\n        } else {\n          map.delete(k);\n          ignored.push(k);\n        }\n      });\n    });\n\n    return map;\n  }\n\n  /**\n   *\n   * @param {Type<any>} target\n   * @returns {Map<string | symbol, PropertyMetadata>}\n   */\n  static getOwnProperties(target: Type<any>): Map<string | symbol, PropertyMetadata> {\n    return Metadata.hasOwn(PROPERTIES_METADATA, target)\n      ? Metadata.getOwn(PROPERTIES_METADATA, target)\n      : new Map<string | symbol, PropertyMetadata>();\n  }\n\n  /**\n   *\n   * @param target\n   * @param propertyKey\n   * @param property\n   */\n  static set(target: Type<any>, propertyKey: string | symbol, property: PropertyMetadata): void {\n    const properties = this.getOwnProperties(target);\n\n    properties.set(propertyKey, property);\n\n    Metadata.set(PROPERTIES_METADATA, properties, target);\n  }\n\n  /**\n   *\n   * @param target\n   * @param propertyKey\n   * @param allowedRequiredValues\n   */\n  static required(target: Type<any>, propertyKey: string | symbol, allowedRequiredValues: any[] = []) {\n    const property = this.get(target, propertyKey);\n\n    property.required = true;\n    property.allowedRequiredValues = allowedRequiredValues.concat(property.allowedRequiredValues);\n\n    this.set(target, propertyKey, property);\n    this.get(target, propertyKey).store.merge(\"responses\", {\n      \"400\": {\n        description: \"BadRequest\"\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   *\n   * @param {(propertyMetadata: PropertyMetadata, parameters: DecoratorParameters) => void} fn\n   * @returns {Function}\n   */\n  static decorate(fn: (propertyMetadata: PropertyMetadata, parameters: DecoratorParameters) => void): Function {\n    return (...parameters: any[]): any => {\n      const propertyMetadata = PropertyRegistry.get(parameters[0], parameters[1]);\n      const result: any = fn(propertyMetadata, parameters as DecoratorParameters);\n      if (typeof result === \"function\") {\n        result(...parameters);\n      }\n    };\n  }\n}\n"],"sourceRoot":"../../../src"}