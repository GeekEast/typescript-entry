{"version":3,"sources":["jsonschema/registries/JsonSchemesRegistry.ts"],"names":[],"mappings":"AAAA,OAAO,EAAoC,QAAQ,EAAS,IAAI,EAAC,MAAM,YAAY,CAAC;AACpF,OAAO,EAAC,WAAW,EAAC,MAAM,aAAa,CAAC;AACxC,OAAO,EAAC,UAAU,EAAC,MAAM,qBAAqB,CAAC;AAM/C,qBAAa,kBAAmB,SAAQ,QAAQ,CAAC,GAAG,EAAE,OAAO,CAAC,UAAU,CAAC,CAAC;IACxE;;;;;;;OAOG;IACH,QAAQ,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,WAAW,EAAE,MAAM,EAAE,IAAI,EAAE,GAAG,EAAE,cAAc,CAAC,EAAE,GAAG,GAAG,UAAU;IAe7F;;;;;OAKG;IACH,OAAO,CAAC,MAAM,CAAC,gBAAgB;IAoB/B;;;;;OAKG;IACH,QAAQ,CAAC,MAAM,EAAE,GAAG,EAAE,WAAW,EAAE,MAAM,EAAE,KAAK,CAAC,EAAE,OAAO;IAiB1D;;;;OAIG;IACH,mBAAmB,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,GAAG,WAAW;IAQnD;;;;OAIG;IACH,OAAO,CAAC,SAAS;IAejB;;;;OAIG;IACH,OAAO,CAAC,cAAc;IAqBtB;;;;;OAKG;IACH,OAAO,CAAC,MAAM;IAkBd;;;;OAIG;IACH,OAAO,CAAC,UAAU;IAIlB;;;;OAIG;IACH,OAAO,CAAC,eAAe;CAUxB;AAGD,eAAO,MAAM,mBAAmB,oBAAqC,CAAC","file":"JsonSchemesRegistry.d.ts","sourcesContent":["import {ancestorsOf, deepExtends, isClass, Registry, Store, Type} from \"@tsed/core\";\nimport {JSONSchema6} from \"json-schema\";\nimport {JsonSchema} from \"../class/JsonSchema\";\n\nconst JSON_SCHEMA_FIELDS = [\"additionalItems\", \"items\", \"additionalProperties\", \"properties\", \"dependencies\", \"oneOf\"];\n\nconst toObj = (o: any) => JSON.parse(JSON.stringify(o));\n\nexport class JsonSchemaRegistry extends Registry<any, Partial<JsonSchema>> {\n  /**\n   *\n   * @param {Type<any>} target\n   * @param {string} propertyKey\n   * @param type\n   * @param collectionType\n   * @returns {JsonSchema}\n   */\n  property(target: Type<any>, propertyKey: string, type: any, collectionType?: any): JsonSchema {\n    if (!this.has(target)) {\n      this.merge(target, {\n        type: target\n      });\n      Store.from(target).set(\"schema\", this.get(target));\n    }\n\n    const schema = this.get(target);\n    schema.properties = schema.properties || {};\n    schema.properties[propertyKey] = JsonSchemaRegistry.createJsonSchema(schema.properties[propertyKey], type, collectionType);\n\n    return schema.properties[propertyKey];\n  }\n\n  /**\n   *\n   * @param schema\n   * @param type\n   * @param collectionType\n   */\n  private static createJsonSchema(schema: JsonSchema = new JsonSchema(), type: any, collectionType?: any): JsonSchema {\n    if (isClass(type)) {\n      schema = Object.keys(schema.toObject()).reduce((newSchema: any, key: string) => {\n        if (!(key === \"type\" || key === \"items\" || key === \"additionalProperties\")) {\n          newSchema[key] = schema[key];\n        }\n\n        return newSchema;\n      }, JsonSchema.ref(type));\n    } else {\n      schema.type = type;\n    }\n\n    if (collectionType) {\n      schema.toCollection(collectionType);\n    }\n\n    return schema!;\n  }\n\n  /**\n   *\n   * @param target\n   * @param {string} propertyKey\n   * @param value\n   */\n  required(target: any, propertyKey: string, value?: boolean) {\n    const schema = this.get(target) || {};\n    const required = schema.required || [];\n\n    if (value !== undefined) {\n      const index = required.indexOf(propertyKey);\n      if (value && index === -1) {\n        schema.required = [].concat(required, [propertyKey as never]);\n      }\n      if (!value && index > -1) {\n        required.splice(required.indexOf(propertyKey), 1);\n      }\n    }\n\n    return (schema.required || []).some((p: string) => p === propertyKey);\n  }\n\n  /**\n   *\n   * @param {Type<any>} target\n   * @returns {JSONSchema6}\n   */\n  getSchemaDefinition(target: Type<any>): JSONSchema6 {\n    return ancestorsOf(target).reduce((acc: JSONSchema6, target: Type<any>) => {\n      deepExtends(acc, this.getSchema(target));\n\n      return acc;\n    }, {});\n  }\n\n  /**\n   *\n   * @param {Type<any>} target\n   * @returns {JSONSchema6}\n   */\n  private getSchema(target: Type<any>) {\n    const schemaDefinition: JSONSchema6 = {};\n    const schema = this.get(target);\n\n    if (schema) {\n      deepExtends(schemaDefinition, toObj(schema));\n    }\n\n    schemaDefinition.definitions = {};\n\n    this.findReferences(schemaDefinition, schemaDefinition.definitions as any);\n\n    return schemaDefinition;\n  }\n\n  /**\n   *\n   * @param {JsonSchema} schema\n   * @param definitions\n   */\n  private findReferences(schema: JSONSchema6, definitions: {[p: string]: JSONSchema6}): JSONSchema6 {\n    if (schema.$ref) {\n      return this.getRef(schema, definitions);\n    }\n\n    JSON_SCHEMA_FIELDS.forEach((key: string) => {\n      const value: any = (schema as any)[key];\n      if (value) {\n        if (value.$ref) {\n          return this.getRef(value, definitions);\n        }\n\n        Object.keys(value).forEach((index: any) => {\n          this.findReferences(value[index], definitions);\n        });\n      }\n    });\n\n    return schema;\n  }\n\n  /**\n   *\n   * @param {JSONSchema4} schema\n   * @param definitions\n   * @returns {JSONSchema4}\n   */\n  private getRef(schema: JSONSchema6, definitions: {[p: string]: JSONSchema6}): JSONSchema6 {\n    const schemaName = this.getRefName(schema.$ref!);\n    const refSchema = this.getSchemaByName(schemaName);\n\n    if (refSchema) {\n      if (!definitions[schemaName]) {\n        definitions[schemaName] = {};\n        this.findReferences(refSchema!, definitions);\n        definitions[schemaName] = refSchema.toObject();\n      }\n    } else {\n      schema.type = \"object\";\n      delete schema.$ref;\n    }\n\n    return schema;\n  }\n\n  /**\n   *\n   * @param {string} ref\n   * @returns {string}\n   */\n  private getRefName(ref: string): string {\n    return ref.replace(\"#/definitions/\", \"\");\n  }\n\n  /**\n   *\n   * @param {string} name\n   * @returns {JsonSchema}\n   */\n  private getSchemaByName(name: string): JsonSchema | undefined {\n    let currentSchema;\n    this.forEach(schema => {\n      if (schema.refName === name) {\n        currentSchema = schema;\n      }\n    });\n\n    return currentSchema;\n  }\n}\n\n// tslint:disable-next-line: variable-name\nexport const JsonSchemesRegistry = new JsonSchemaRegistry(JsonSchema);\n"],"sourceRoot":"../../../src"}