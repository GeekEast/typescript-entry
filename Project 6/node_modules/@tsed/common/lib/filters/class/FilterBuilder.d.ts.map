{"version":3,"sources":["filters/class/FilterBuilder.ts"],"names":[],"mappings":"AACA,OAAO,EAAC,eAAe,EAAC,MAAM,UAAU,CAAC;AAQzC,OAAO,EAAC,aAAa,EAAC,MAAM,iBAAiB,CAAC;AAE9C,qBAAa,aAAa;IACZ,OAAO,CAAC,QAAQ;gBAAR,QAAQ,EAAE,eAAe;IAE7C;;;;;;OAMG;IACH,OAAO,CAAC,MAAM,CAAC,IAAI;IAInB;;OAEG;IACI,KAAK,CAAC,KAAK,EAAE,aAAa,GAAG,QAAQ;IAS5C;;;;;OAKG;IACH,OAAO,CAAC,MAAM;IAYd;;;;OAIG;IACH,OAAO,CAAC,UAAU;IAelB;;;;;OAKG;IACH,OAAO,CAAC,oBAAoB;IAiB5B;;;;;OAKG;IACH,OAAO,CAAC,qBAAqB;IAe7B;;;;;OAKG;IACH,OAAO,CAAC,sBAAsB;CAuB/B","file":"FilterBuilder.d.ts","sourcesContent":["import {Type} from \"@tsed/core\";\nimport {InjectorService} from \"@tsed/di\";\nimport {ConverterService} from \"../../converters\";\nimport {ParseExpressionError} from \"../errors/ParseExpressionError\";\nimport {RequiredParamError} from \"../errors/RequiredParamError\";\nimport {UnknowFilterError} from \"../errors/UnknowFilterError\";\nimport {IFilter, IFilterPreHandler, IFilterScope} from \"../interfaces\";\nimport {FilterPreHandlers} from \"../registries/FilterRegistry\";\nimport {ValidationService} from \"../services/ValidationService\";\nimport {ParamMetadata} from \"./ParamMetadata\";\n\nexport class FilterBuilder {\n  constructor(private injector: InjectorService) {}\n\n  /**\n   *\n   * @param {Function} filter\n   * @param {Function} newFilter\n   * @param args\n   * @returns {(value: any) => any}\n   */\n  private static pipe(filter: Function, newFilter: Function, ...args: any[]): Function {\n    return (value: any) => newFilter(filter(value), ...args);\n  }\n\n  /**\n   *\n   */\n  public build(param: ParamMetadata): Function {\n    let filter: any = this.initFilter(param);\n    filter = this.appendRequiredFilter(filter, param);\n    filter = this.appendValidationFilter(filter, param);\n    filter = this.appendConverterFilter(filter, param);\n\n    return filter;\n  }\n\n  /**\n   *\n   * @param {Type<IFilter>} target\n   * @param args\n   * @returns {any}\n   */\n  private invoke(target: Type<IFilter>, ...args: any[]): any {\n    const instance = this.injector.get<IFilter>(target);\n\n    if (!instance || !instance.transform) {\n      throw new UnknowFilterError(target);\n    }\n\n    const [expression, request, response] = args;\n\n    return instance.transform(expression, request, response);\n  }\n\n  /**\n   *\n   * @param {ParamMetadata} param\n   * @returns {any}\n   */\n  private initFilter(param: ParamMetadata): IFilterPreHandler {\n    if (typeof param.service === \"symbol\") {\n      const sym = param.service as symbol;\n\n      if (FilterPreHandlers.has(sym)) {\n        return FilterPreHandlers.get(sym)!;\n      }\n    }\n\n    // wrap Custom Filter to FilterPreHandler\n    return (locals: IFilterScope) => {\n      return this.invoke(param.service as Type<any>, param.expression, locals.request, locals.response);\n    };\n  }\n\n  /**\n   *\n   * @param filter\n   * @param {ParamMetadata} param\n   * @returns {(value: any) => any}\n   */\n  private appendRequiredFilter(filter: any, param: ParamMetadata): Function {\n    if (!param.required) {\n      return filter;\n    }\n\n    return FilterBuilder.pipe(\n      filter,\n      (value: any) => {\n        if (param.isRequired(value)) {\n          throw new RequiredParamError(param.name, param.expression);\n        }\n\n        return value;\n      }\n    );\n  }\n\n  /**\n   *\n   * @param filter\n   * @param param\n   * @returns {(value: any) => any}\n   */\n  private appendConverterFilter(filter: any, param: ParamMetadata): Function {\n    if (!param.useConverter) {\n      return filter;\n    }\n\n    const converterService = this.injector.get<ConverterService>(ConverterService)!;\n\n    return FilterBuilder.pipe(\n      filter,\n      converterService.deserialize.bind(converterService),\n      param.collectionType || param.type,\n      param.type\n    );\n  }\n\n  /**\n   *\n   * @param filter\n   * @param param\n   * @returns {(value: any) => any}\n   */\n  private appendValidationFilter(filter: any, param: ParamMetadata): Function {\n    const type = param.type || param.collectionType;\n    const {collectionType} = param;\n\n    if (!param.useValidation || (param.useValidation && !type)) {\n      return filter;\n    }\n\n    const validationService = this.injector.get<ValidationService>(ValidationService)!;\n\n    return FilterBuilder.pipe(\n      filter,\n      (value: any) => {\n        try {\n          validationService.validate(value, type, collectionType);\n        } catch (err) {\n          throw new ParseExpressionError(param.name, param.expression, err);\n        }\n\n        return value;\n      }\n    );\n  }\n}\n"],"sourceRoot":"../../../src"}