"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const converters_1 = require("../../converters");
const ParseExpressionError_1 = require("../errors/ParseExpressionError");
const RequiredParamError_1 = require("../errors/RequiredParamError");
const UnknowFilterError_1 = require("../errors/UnknowFilterError");
const FilterRegistry_1 = require("../registries/FilterRegistry");
const ValidationService_1 = require("../services/ValidationService");
class FilterBuilder {
    constructor(injector) {
        this.injector = injector;
    }
    /**
     *
     * @param {Function} filter
     * @param {Function} newFilter
     * @param args
     * @returns {(value: any) => any}
     */
    static pipe(filter, newFilter, ...args) {
        return (value) => newFilter(filter(value), ...args);
    }
    /**
     *
     */
    build(param) {
        let filter = this.initFilter(param);
        filter = this.appendRequiredFilter(filter, param);
        filter = this.appendValidationFilter(filter, param);
        filter = this.appendConverterFilter(filter, param);
        return filter;
    }
    /**
     *
     * @param {Type<IFilter>} target
     * @param args
     * @returns {any}
     */
    invoke(target, ...args) {
        const instance = this.injector.get(target);
        if (!instance || !instance.transform) {
            throw new UnknowFilterError_1.UnknowFilterError(target);
        }
        const [expression, request, response] = args;
        return instance.transform(expression, request, response);
    }
    /**
     *
     * @param {ParamMetadata} param
     * @returns {any}
     */
    initFilter(param) {
        if (typeof param.service === "symbol") {
            const sym = param.service;
            if (FilterRegistry_1.FilterPreHandlers.has(sym)) {
                return FilterRegistry_1.FilterPreHandlers.get(sym);
            }
        }
        // wrap Custom Filter to FilterPreHandler
        return (locals) => {
            return this.invoke(param.service, param.expression, locals.request, locals.response);
        };
    }
    /**
     *
     * @param filter
     * @param {ParamMetadata} param
     * @returns {(value: any) => any}
     */
    appendRequiredFilter(filter, param) {
        if (!param.required) {
            return filter;
        }
        return FilterBuilder.pipe(filter, (value) => {
            if (param.isRequired(value)) {
                throw new RequiredParamError_1.RequiredParamError(param.name, param.expression);
            }
            return value;
        });
    }
    /**
     *
     * @param filter
     * @param param
     * @returns {(value: any) => any}
     */
    appendConverterFilter(filter, param) {
        if (!param.useConverter) {
            return filter;
        }
        const converterService = this.injector.get(converters_1.ConverterService);
        return FilterBuilder.pipe(filter, converterService.deserialize.bind(converterService), param.collectionType || param.type, param.type);
    }
    /**
     *
     * @param filter
     * @param param
     * @returns {(value: any) => any}
     */
    appendValidationFilter(filter, param) {
        const type = param.type || param.collectionType;
        const { collectionType } = param;
        if (!param.useValidation || (param.useValidation && !type)) {
            return filter;
        }
        const validationService = this.injector.get(ValidationService_1.ValidationService);
        return FilterBuilder.pipe(filter, (value) => {
            try {
                validationService.validate(value, type, collectionType);
            }
            catch (err) {
                throw new ParseExpressionError_1.ParseExpressionError(param.name, param.expression, err);
            }
            return value;
        });
    }
}
exports.FilterBuilder = FilterBuilder;

//# sourceMappingURL=FilterBuilder.js.map
