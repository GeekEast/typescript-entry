{"version":3,"sources":["filters/registries/ParamRegistry.ts"],"names":[],"mappings":"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","file":"ParamRegistry.js","sourcesContent":["import {Metadata, Type} from \"@tsed/core\";\nimport {ParamMetadata} from \"../class/ParamMetadata\";\nimport {PARAM_METADATA} from \"../constants\";\nimport {IInjectableParamSettings} from \"../interfaces\";\nimport {IParamArgs} from \"../interfaces/Arguments\";\n\nexport class ParamRegistry {\n  /**\n   *\n   * @param target\n   * @param targetKey\n   * @param index\n   * @returns {any}\n   */\n  static get(target: Type<any>, targetKey: string | symbol, index: number): ParamMetadata {\n    const params = this.getParams(target, targetKey);\n\n    params[index] = params[index] || new ParamMetadata(target, targetKey, index);\n\n    return params[index];\n  }\n\n  /**\n   *\n   * @param target\n   * @param targetKey\n   * @returns {Array}\n   */\n  static getParams = (target: Type<any>, targetKey?: string | symbol): ParamMetadata[] =>\n    Metadata.has(PARAM_METADATA, target, targetKey) ? Metadata.get(PARAM_METADATA, target, targetKey) : [];\n\n  /**\n   *\n   * @param target\n   * @param targetKey\n   * @param index\n   * @param injectParams\n   */\n  static set(target: Type<any>, targetKey: string | symbol, index: number, injectParams: ParamMetadata): void {\n    const params = Metadata.has(PARAM_METADATA, target, targetKey) ? Metadata.get(PARAM_METADATA, target, targetKey) : [];\n\n    params[index] = injectParams;\n\n    Metadata.set(PARAM_METADATA, params, target, targetKey);\n  }\n\n  /**\n   *\n   * @param service\n   * @param settings\n   */\n  static usePreHandler(service: symbol, settings: IParamArgs<any>) {\n    const param = ParamRegistry.get(settings.target, settings.propertyKey, settings.parameterIndex);\n    param.service = service;\n    param.useConverter = false;\n\n    ParamRegistry.set(settings.target, settings.propertyKey, settings.parameterIndex, param);\n\n    return this;\n  }\n\n  /**\n   *\n   * @param target\n   * @param propertyKey\n   * @param parameterIndex\n   * @param allowedRequiredValues\n   */\n  static required(target: Type<any>, propertyKey: string | symbol, parameterIndex: number, allowedRequiredValues: any[] = []) {\n    const param = ParamRegistry.get(target, propertyKey, parameterIndex);\n\n    param.required = true;\n    param.allowedRequiredValues = allowedRequiredValues;\n\n    ParamRegistry.set(target, propertyKey, parameterIndex, param);\n\n    ParamRegistry.get(target, propertyKey, parameterIndex).store.merge(\"responses\", {\n      \"400\": {\n        description: \"BadRequest\"\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Create a parameters decorators\n   * @param token\n   * @param {Partial<IInjectableParamSettings<any>>} options\n   * @returns {Function}\n   */\n  static decorate(token: Type<any> | symbol, options: Partial<IInjectableParamSettings<any>> = {}): ParameterDecorator {\n    return (target: Type<any>, propertyKey: string | symbol, parameterIndex: number): any => {\n      if (typeof parameterIndex === \"number\") {\n        const settings = Object.assign(\n          {\n            target,\n            propertyKey,\n            parameterIndex\n          },\n          options\n        );\n\n        if (typeof token === \"symbol\") {\n          ParamRegistry.usePreHandler(token, settings);\n        } else {\n          ParamRegistry.useFilter(token, settings);\n        }\n      }\n    };\n  }\n\n  /**\n   *\n   * @param service\n   * @param options\n   */\n  static useFilter(service: Type<any>, options: IInjectableParamSettings<any>): ParamMetadata {\n    const {propertyKey, parameterIndex, target, useConverter, useValidation, paramType} = options;\n\n    let {expression, useType} = options;\n\n    const param = ParamRegistry.get(target, propertyKey, parameterIndex);\n\n    if (typeof expression !== \"string\") {\n      useType = expression as any;\n      expression = undefined;\n    }\n\n    param.service = service;\n    param.expression = expression!;\n    param.useValidation = !!useValidation;\n\n    if (paramType) {\n      param.paramType = paramType!;\n    }\n\n    if (useType) {\n      param.type = useType;\n    }\n\n    if (useConverter !== undefined) {\n      param.useConverter = useConverter;\n    }\n\n    ParamRegistry.set(target, propertyKey, parameterIndex, param);\n\n    return param;\n  }\n}\n"],"sourceRoot":"../../../src"}