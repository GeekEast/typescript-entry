{"version":3,"sources":["filters/registries/ParamRegistry.ts"],"names":[],"mappings":"AAAA,OAAO,EAAW,IAAI,EAAC,MAAM,YAAY,CAAC;AAC1C,OAAO,EAAC,aAAa,EAAC,MAAM,wBAAwB,CAAC;AAErD,OAAO,EAAC,wBAAwB,EAAC,MAAM,eAAe,CAAC;AACvD,OAAO,EAAC,UAAU,EAAC,MAAM,yBAAyB,CAAC;AAEnD,qBAAa,aAAa;IACxB;;;;;;OAMG;IACH,MAAM,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,SAAS,EAAE,MAAM,GAAG,MAAM,EAAE,KAAK,EAAE,MAAM,GAAG,aAAa;IAQvF;;;;;OAKG;IACH,MAAM,CAAC,SAAS,kFACyF;IAEzG;;;;;;OAMG;IACH,MAAM,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,SAAS,EAAE,MAAM,GAAG,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,YAAY,EAAE,aAAa,GAAG,IAAI;IAQ3G;;;;OAIG;IACH,MAAM,CAAC,aAAa,CAAC,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,UAAU,CAAC,GAAG,CAAC;IAU/D;;;;;;OAMG;IACH,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,WAAW,EAAE,MAAM,GAAG,MAAM,EAAE,cAAc,EAAE,MAAM,EAAE,qBAAqB,GAAE,GAAG,EAAO;IAiB1H;;;;;OAKG;IACH,MAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,GAAG,MAAM,EAAE,OAAO,GAAE,OAAO,CAAC,wBAAwB,CAAC,GAAG,CAAC,CAAM,GAAG,kBAAkB;IAqBpH;;;;OAIG;IACH,MAAM,CAAC,SAAS,CAAC,OAAO,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,OAAO,EAAE,wBAAwB,CAAC,GAAG,CAAC,GAAG,aAAa;CAgC5F","file":"ParamRegistry.d.ts","sourcesContent":["import {Metadata, Type} from \"@tsed/core\";\nimport {ParamMetadata} from \"../class/ParamMetadata\";\nimport {PARAM_METADATA} from \"../constants\";\nimport {IInjectableParamSettings} from \"../interfaces\";\nimport {IParamArgs} from \"../interfaces/Arguments\";\n\nexport class ParamRegistry {\n  /**\n   *\n   * @param target\n   * @param targetKey\n   * @param index\n   * @returns {any}\n   */\n  static get(target: Type<any>, targetKey: string | symbol, index: number): ParamMetadata {\n    const params = this.getParams(target, targetKey);\n\n    params[index] = params[index] || new ParamMetadata(target, targetKey, index);\n\n    return params[index];\n  }\n\n  /**\n   *\n   * @param target\n   * @param targetKey\n   * @returns {Array}\n   */\n  static getParams = (target: Type<any>, targetKey?: string | symbol): ParamMetadata[] =>\n    Metadata.has(PARAM_METADATA, target, targetKey) ? Metadata.get(PARAM_METADATA, target, targetKey) : [];\n\n  /**\n   *\n   * @param target\n   * @param targetKey\n   * @param index\n   * @param injectParams\n   */\n  static set(target: Type<any>, targetKey: string | symbol, index: number, injectParams: ParamMetadata): void {\n    const params = Metadata.has(PARAM_METADATA, target, targetKey) ? Metadata.get(PARAM_METADATA, target, targetKey) : [];\n\n    params[index] = injectParams;\n\n    Metadata.set(PARAM_METADATA, params, target, targetKey);\n  }\n\n  /**\n   *\n   * @param service\n   * @param settings\n   */\n  static usePreHandler(service: symbol, settings: IParamArgs<any>) {\n    const param = ParamRegistry.get(settings.target, settings.propertyKey, settings.parameterIndex);\n    param.service = service;\n    param.useConverter = false;\n\n    ParamRegistry.set(settings.target, settings.propertyKey, settings.parameterIndex, param);\n\n    return this;\n  }\n\n  /**\n   *\n   * @param target\n   * @param propertyKey\n   * @param parameterIndex\n   * @param allowedRequiredValues\n   */\n  static required(target: Type<any>, propertyKey: string | symbol, parameterIndex: number, allowedRequiredValues: any[] = []) {\n    const param = ParamRegistry.get(target, propertyKey, parameterIndex);\n\n    param.required = true;\n    param.allowedRequiredValues = allowedRequiredValues;\n\n    ParamRegistry.set(target, propertyKey, parameterIndex, param);\n\n    ParamRegistry.get(target, propertyKey, parameterIndex).store.merge(\"responses\", {\n      \"400\": {\n        description: \"BadRequest\"\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Create a parameters decorators\n   * @param token\n   * @param {Partial<IInjectableParamSettings<any>>} options\n   * @returns {Function}\n   */\n  static decorate(token: Type<any> | symbol, options: Partial<IInjectableParamSettings<any>> = {}): ParameterDecorator {\n    return (target: Type<any>, propertyKey: string | symbol, parameterIndex: number): any => {\n      if (typeof parameterIndex === \"number\") {\n        const settings = Object.assign(\n          {\n            target,\n            propertyKey,\n            parameterIndex\n          },\n          options\n        );\n\n        if (typeof token === \"symbol\") {\n          ParamRegistry.usePreHandler(token, settings);\n        } else {\n          ParamRegistry.useFilter(token, settings);\n        }\n      }\n    };\n  }\n\n  /**\n   *\n   * @param service\n   * @param options\n   */\n  static useFilter(service: Type<any>, options: IInjectableParamSettings<any>): ParamMetadata {\n    const {propertyKey, parameterIndex, target, useConverter, useValidation, paramType} = options;\n\n    let {expression, useType} = options;\n\n    const param = ParamRegistry.get(target, propertyKey, parameterIndex);\n\n    if (typeof expression !== \"string\") {\n      useType = expression as any;\n      expression = undefined;\n    }\n\n    param.service = service;\n    param.expression = expression!;\n    param.useValidation = !!useValidation;\n\n    if (paramType) {\n      param.paramType = paramType!;\n    }\n\n    if (useType) {\n      param.type = useType;\n    }\n\n    if (useConverter !== undefined) {\n      param.useConverter = useConverter;\n    }\n\n    ParamRegistry.set(target, propertyKey, parameterIndex, param);\n\n    return param;\n  }\n}\n"],"sourceRoot":"../../../src"}