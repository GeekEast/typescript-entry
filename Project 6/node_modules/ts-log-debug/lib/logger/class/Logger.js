"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LoggerAppenders_1 = require("./LoggerAppenders");
const tableUtils_1 = require("../utils/tableUtils");
const LogEvent_1 = require("../../core/LogEvent");
const LogLevel_1 = require("../../core/LogLevel");
class Logger {
    /**
     *
     */
    constructor(_name = "default") {
        this._name = _name;
        this._appenders = new LoggerAppenders_1.LoggerAppenders();
        /**
         *
         */
        this._context = new Map();
        this.level = "all";
    }
    get appenders() {
        return this._appenders;
    }
    get level() {
        return this._level.toString();
    }
    set level(level) {
        this._level = LogLevel_1.LogLevel.getLevel(level, "debug");
    }
    get context() {
        return this._context;
    }
    get name() {
        return this._name;
    }
    set name(value) {
        this._name = value;
    }
    /**
     * Create stack trace  the lines of least Logger.
     * @returns {string}
     */
    static createStack() {
        const stack = new Error().stack.replace("Error\n", "");
        const array = stack.split("\n");
        /* istanbul ignore else */
        if (array[0].indexOf("Logger.") > -1) {
            // remove current function
            array.splice(0, 1);
        }
        /* istanbul ignore else */
        if (array[0].indexOf("Logger.") > -1) {
            // remove caller
            array.splice(0, 1);
        }
        return array.join("\n");
    }
    isLevelEnabled(otherLevel) {
        return this._level.isLessThanOrEqualTo(otherLevel);
    }
    /**
     * Prints to stdout with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to printf() (the arguments are all passed to util.format()).
     * @param data
     * @returns {any}
     */
    debug(...data) {
        return this.write(LogLevel_1.levels().DEBUG, data);
    }
    /**
     *
     * @param data
     * @returns {any}
     */
    info(...data) {
        return this.write(LogLevel_1.levels().INFO, data);
    }
    /**
     *
     * @param data
     * @returns {any}
     */
    warn(...data) {
        return this.write(LogLevel_1.levels().WARN, data);
    }
    /**
     * Prints to stderr with newline. Multiple arguments can be passed, with the first used as the primary
     * message and all additional used as substitution values similar to printf() (the arguments are all
     * passed to util.format()).
     * @param data
     * @param args
     * @returns {any}
     */
    error(...data) {
        return this.write(LogLevel_1.levels().ERROR, data);
    }
    fatal(...data) {
        return this.write(LogLevel_1.levels().FATAL, data);
    }
    /**
     *
     * @param data
     * @returns {Logger}
     */
    trace(...data) {
        const stack = "\n" + Logger.createStack() + "\n";
        data.push(stack);
        return this.write(LogLevel_1.levels().TRACE, data);
    }
    /**
     *
     */
    start() {
        this.level = "ALL";
        return this;
    }
    /**
     *
     */
    stop() {
        this.level = "OFF";
        return this;
    }
    /**
     *
     * @returns {Promise<TAll[]>}
     */
    shutdown() {
        this.stop();
        const promises = this.appenders
            .toArray()
            .filter(appender => !!appender.instance.shutdown)
            .map(appender => appender.instance.shutdown());
        return Promise.all(promises);
    }
    /**
     *
     * @param list
     * @param settings
     */
    drawTable(list, settings = {}) {
        return tableUtils_1.drawTable(list, settings);
    }
    /**
     *
     * @param list
     * @param settings
     * @returns {Logger}
     */
    printTable(list, settings = {}) {
        this.info(`\n${this.drawTable(list, settings)}`);
        return this;
    }
    /**
     *
     * @returns {Logger}
     */
    write(logLevel, data) {
        if (!this.isLevelEnabled(logLevel))
            return this;
        const logEvent = new LogEvent_1.LogEvent(this._name, logLevel, data, this._context);
        this.appenders.byLogLevel(logLevel).forEach((appender) => {
            appender.write(logEvent);
        });
        return this;
    }
}
exports.Logger = Logger;
//# sourceMappingURL=Logger.js.map