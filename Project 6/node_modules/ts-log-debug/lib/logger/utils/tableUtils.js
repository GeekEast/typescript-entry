"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function charRepeater(x, char = " ") {
    let res = "";
    while (x--)
        res += char;
    return res;
}
exports.charRepeater = charRepeater;
/**
 *
 * @returns {string}
 */
function buildStartLine(fields, settings) {
    let line = "┌";
    let list = Object.keys(fields);
    list.forEach((key, index) => {
        if (index !== 0 && index !== list.length) {
            line += "┬";
        }
        line += charRepeater(fields[key] + 2 * settings.padding, "─");
    });
    line += "┐";
    return line;
}
exports.buildStartLine = buildStartLine;
/**
 *
 * @param fields
 * @param settings
 * @returns {string}
 */
function buildEndLine(fields, settings) {
    let line = "└";
    let list = Object.keys(fields);
    list.forEach((key, index) => {
        if (index !== 0 && index !== list.length) {
            line += "┴";
        }
        line += charRepeater(fields[key] + 2 * settings.padding, "─");
    });
    line += "┘";
    return line;
}
exports.buildEndLine = buildEndLine;
/**
 *
 * @param fields
 * @param settings
 * @param char
 * @returns {string}
 */
function buildLine(fields, settings, char = "─") {
    let line = "";
    Object.keys(fields).forEach(key => {
        line += "│";
        line += charRepeater(fields[key] + 2 * settings.padding, char);
    });
    line += "│";
    return line;
}
exports.buildLine = buildLine;
/**
 *
 */
function buildLineData(scope, fields, settings) {
    let line = "";
    Object.keys(fields).forEach(key => {
        line += "│ ";
        line += scope[key];
        line += charRepeater(fields[key] + 2 * (settings.padding - 1) - scope[key].length, " ");
        line += " ";
    });
    line += "│";
    return line;
}
exports.buildLineData = buildLineData;
/**
 *
 * @param list
 * @param settings
 * @returns {string}
 */
function drawTable(list, settings = {}) {
    settings.padding = settings.padding || 1;
    if (settings.header === undefined) {
        settings.header = {};
        Object.keys(list[0]).forEach(key => (settings.header[key] = key));
    }
    const fields = {};
    // Calculate width for each column
    Object.keys(settings.header).forEach(key => (fields[key] = settings.header[key].length));
    list.forEach(route => {
        Object.keys(fields).forEach(key => (fields[key] = Math.max(("" + route[key]).length, fields[key])));
    });
    let output = "";
    output += buildStartLine(fields, settings) + "\n";
    output += buildLineData(settings.header, fields, settings) + "\n";
    list.forEach(scope => {
        output += buildLine(fields, settings) + "\n";
        output += buildLineData(scope, fields, settings) + "\n";
    });
    output += buildEndLine(fields, settings);
    return output;
}
exports.drawTable = drawTable;
//# sourceMappingURL=tableUtils.js.map